<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ultimate Solar System: Glowing Sun</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: 'Segoe UI', Arial, sans-serif;
            font-size: 14px;
            pointer-events: none;
            z-index: 10;
            text-shadow: 0 0 5px #000;
        }
        #loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #ffcc00; font-family: sans-serif;
            font-size: 24px;
            pointer-events: none;
            text-shadow: 0 0 10px #ffcc00;
        }
    </style>
</head>
<body>

    <div id="info">
        <b>Ultimate 3D Solar System</b><br>
        Glowing Sun (Sprite) + NASA Textures + Asteroid Belt<br>
        Scroll to Zoom | Drag to Rotate
    </div>
    <div id="loading">Initialize Physics & Loading Textures...</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 3000);
        camera.position.set(-60, 40, 80); 

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Softer shadows
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 20;
        controls.maxDistance = 800;

        // --- ASSET LOADING ---
        const textureLoader = new THREE.TextureLoader();
        const loadingMgr = new THREE.LoadingManager();
        loadingMgr.onLoad = () => { document.getElementById('loading').style.display = 'none'; };
        const managedLoader = new THREE.TextureLoader(loadingMgr);

        const texBase = "https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/planets/";
        const texExt = "https://raw.githubusercontent.com/simondevyoutube/ThreeJS_Tutorial_Textures/main/ solar_system_textures/";

        // --- 1. THE GLOWING SUN (Engineering Highlight) ---
        
        // A. The Physical Light Source
        const sunLight = new THREE.PointLight(0xffffff, 2.5, 600);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048; // High res shadow map
        sunLight.shadow.mapSize.height = 2048;
        scene.add(sunLight);

        // Ambient light for dark areas
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5); 
        scene.add(ambientLight);

        // B. The Sun Mesh (The Core)
        const sunGeo = new THREE.SphereGeometry(5, 64, 64);
        const sunMat = new THREE.MeshBasicMaterial({ 
            map: managedLoader.load(texBase + 'sun.jpg'),
            color: 0xffffff // Pure brightness
        });
        const sun = new THREE.Mesh(sunGeo, sunMat);
        scene.add(sun);

        // C. The Sun Glow (The Corona) - Procedural Texture Generation
        function createGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const context = canvas.getContext('2d');
            // Create a radial gradient (white center -> yellow -> transparent edge)
            const gradient = context.createRadialGradient(64, 64, 0, 64, 64, 64);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.2, 'rgba(255, 255, 220, 0.8)');
            gradient.addColorStop(0.5, 'rgba(255, 200, 80, 0.3)');
            gradient.addColorStop(1, 'rgba(255, 100, 0, 0)');
            
            context.fillStyle = gradient;
            context.fillRect(0, 0, 128, 128);
            return new THREE.CanvasTexture(canvas);
        }

        const glowMaterial = new THREE.SpriteMaterial({ 
            map: createGlowTexture(),
            color: 0xffaa00,
            transparent: true,
            opacity: 0.9,
            blending: THREE.AdditiveBlending // Adds light to background
        });
        const sunGlow = new THREE.Sprite(glowMaterial);
        sunGlow.scale.set(25, 25, 1); // Make it much bigger than the sun
        scene.add(sunGlow); // Sprites always face the camera


        // --- 2. PLANETS ---
        function createPlanet(size, textureFileName, distance, speed, name, hasBump = false) {
            const geometry = new THREE.SphereGeometry(size, 64, 64);
            const materialConfig = {
                map: managedLoader.load(texBase + textureFileName),
                roughness: 0.8,
                metalness: 0.2
            };
            
            // Special texture handling
            if (name === 'Venus') materialConfig.map = managedLoader.load(texExt + 'venus_atmosphere.jpg');
            if (name === 'Mercury') materialConfig.map = managedLoader.load(texExt + 'mercury.jpg');
            if (name === 'Saturn') materialConfig.map = managedLoader.load(texExt + 'saturn.jpg');
            if (name === 'Uranus') materialConfig.map = managedLoader.load(texExt + 'uranus.jpg');
            if (name === 'Neptune') materialConfig.map = managedLoader.load(texExt + 'neptune.jpg');
            if (name === 'Pluto') materialConfig.map = managedLoader.load(texExt + 'pluto.jpg');

            if (hasBump && name === 'Earth') {
                 materialConfig.bumpMap = managedLoader.load(texBase + 'earth_bump.jpg');
                 materialConfig.bumpScale = 0.05;
            }

            const material = new THREE.MeshStandardMaterial(materialConfig);
            const planet = new THREE.Mesh(geometry, material);
            planet.castShadow = true;
            planet.receiveShadow = true;
            
            // Subtle Orbit Line
            const orbitGeo = new THREE.RingGeometry(distance - 0.1, distance + 0.1, 128);
            const orbitMat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, opacity: 0.05, transparent: true });
            const orbit = new THREE.Mesh(orbitGeo, orbitMat);
            orbit.rotation.x = -Math.PI / 2;
            scene.add(orbit);

            return {
                mesh: planet,
                distance: distance,
                speed: speed,
                angle: Math.random() * Math.PI * 2,
                selfRotationSpeed: 0.005 + Math.random() * 0.01
            };
        }

        const planetsData = [
            { name: "Mercury", size: 0.8, tex: 'moon_1024.jpg', dist: 12, speed: 0.03 },
            { name: "Venus",   size: 1.2, tex: 'venus_surface.jpg', dist: 18, speed: 0.02 },
            { name: "Earth",   size: 1.3, tex: 'earth_atmos_2048.jpg', dist: 26, speed: 0.015, bump: true },
            { name: "Mars",    size: 1.0, tex: 'mars_1k.jpg', dist: 35, speed: 0.012 },
            { name: "Jupiter", size: 4.5, tex: 'jupiter_2k.jpg', dist: 55, speed: 0.006 },
            { name: "Saturn",  size: 3.8, tex: 'saturn_2k.jpg', dist: 75, speed: 0.0045 },
            { name: "Uranus",  size: 2.5, tex: 'uranus_2k.jpg', dist: 95, speed: 0.003 },
            { name: "Neptune", size: 2.5, tex: 'neptune_2k.jpg', dist: 115, speed: 0.002 },
            { name: "Pluto",   size: 0.6, tex: 'moon_1024.jpg', dist: 135, speed: 0.001 } 
        ];

        const planets = planetsData.map(d => {
            const p = createPlanet(d.size, d.tex, d.dist, d.speed, d.name, d.bump);
            scene.add(p.mesh);
            return p;
        });

        // --- 3. SPECIAL FEATURES ---
        
        // Earth Moon
        const earthObj = planets[2];
        const moon = new THREE.Mesh(
            new THREE.SphereGeometry(0.35, 16, 16),
            new THREE.MeshStandardMaterial({ map: managedLoader.load(texBase + 'moon_1024.jpg') })
        );
        moon.castShadow = true; 
        moon.receiveShadow = true;
        earthObj.mesh.add(moon);
        let moonAngle = 0;

        // Saturn Rings
        const saturnObj = planets[5];
        const ringTex = managedLoader.load(texExt + 'saturn_ring.png');
        ringTex.rotation = Math.PI / 2;
        const ring = new THREE.Mesh(
            new THREE.RingGeometry(4.8, 8, 64),
            new THREE.MeshStandardMaterial({ 
                map: ringTex, side: THREE.DoubleSide, transparent: true, opacity: 0.9 
            })
        );
        ring.rotation.x = Math.PI / 2.1;
        ring.receiveShadow = true;
        saturnObj.mesh.add(ring);

        // --- 4. ASTEROID BELT (Instancing) ---
        let asteroids;
        const asteroidCount = 4000;
        const asteroidGeo = new THREE.DodecahedronGeometry(0.25, 0);
        const asteroidMat = new THREE.MeshStandardMaterial({ 
            color: 0x666666, roughness: 0.8, flatShading: true 
        });
        asteroids = new THREE.InstancedMesh(asteroidGeo, asteroidMat, asteroidCount);
        
        const dummy = new THREE.Object3D();
        for(let i=0; i<asteroidCount; i++){
            // Position between Mars (35) and Jupiter (55) -> approx 40-48
            const angle = Math.random() * Math.PI * 2;
            const dist = 40 + Math.random() * 10; 
            const height = (Math.random() - 0.5) * 2; 
            
            dummy.position.set(Math.cos(angle)*dist, height, Math.sin(angle)*dist);
            dummy.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, 0);
            dummy.scale.setScalar(Math.random() * 0.5 + 0.3);
            dummy.updateMatrix();
            asteroids.setMatrixAt(i, dummy.matrix);
        }
        scene.add(asteroids);

        // --- 5. BACKGROUND STARS (Galaxy) ---
        const starGeo = new THREE.SphereGeometry(1500, 32, 32);
        const starMat = new THREE.MeshBasicMaterial({
            map: managedLoader.load(texExt + 'stars_milky_way.jpg'),
            side: THREE.BackSide
        });
        const starField = new THREE.Mesh(starGeo, starMat);
        scene.add(starField);

        // --- 6. ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            // Sun visual rotation
            sun.rotation.y += 0.002;
            
            // Asteroid Belt Rotation
            asteroids.rotation.y += 0.0005;

            // Planets Orbit
            planets.forEach(p => {
                p.angle += p.speed;
                p.mesh.position.x = Math.cos(p.angle) * p.distance;
                p.mesh.position.z = Math.sin(p.angle) * p.distance;
                p.mesh.rotation.y += p.selfRotationSpeed;
            });

            // Moon Orbit
            moonAngle += 0.02;
            moon.position.set(Math.cos(moonAngle)*3, 0, Math.sin(moonAngle)*3);

            controls.update();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>