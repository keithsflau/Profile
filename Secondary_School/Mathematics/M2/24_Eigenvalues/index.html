<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Eigenvalues & Eigenvectors | M2 Matrix</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script
      crossorigin
      src="https://unpkg.com/react@18/umd/react.production.min.js"
    ></script>
    <script
      crossorigin
      src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"
    ></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600;800&family=JetBrains+Mono:wght@400;500&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/js/all.min.js"></script>
    <style>
      body {
        font-family: "Outfit", sans-serif;
        background: #0f172a;
        color: #e2e8f0;
      }
      .glass {
        background: rgba(30, 41, 59, 0.7);
        backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.1);
      }
      .draggable {
        cursor: grab;
      }
    </style>
  </head>
  <body class="min-h-screen flex flex-col">
    <div id="root" class="flex-grow flex flex-col"></div>
    <script type="text/babel">
      const { useState, useRef } = React;

      const translations = {
        en: {
          unit: "Unit 4: Matrices",
          title: "Eigen Vector Game",
          subtitle: "Find the vectors that stay parallel!",
          goal: "Goal",
          goalDesc:
            "Drag the yellow vector <strong class='text-amber-400'>v</strong> until it lines up perfectly with the red vector <strong class='text-rose-400'>Av</strong>.",
          scale: "Scale Factor:",
          matrix: "Matrix M",
          edit: "Edit matrix values to change problem",
          trueEigen: "True Eigenvalues:",
          found: "EIGENVECTOR FOUND!",
          langBtn: "中文",
        },
        zh: {
          unit: "第四單元：矩陣",
          title: "特徵向量遊戲",
          subtitle: "尋找保持平行的向量！",
          goal: "目標",
          goalDesc:
            "拖動黃色向量 <strong class='text-amber-400'>v</strong>，直到它與紅色向量 <strong class='text-rose-400'>Av</strong> 完全重合（平行）。",
          scale: "縮放因子 (特徵值):",
          matrix: "矩陣 M",
          edit: "修改矩陣數值以變更題目",
          trueEigen: "真實特徵值:",
          found: "找到特徵向量！",
          langBtn: "English",
        },
      };

      const App = () => {
        // Matrix M = [2 1; 1 2] (Symmetric, real eigenvalues)
        // Default M

        const [lang, setLang] = useState("en");
        const t = translations[lang];

        const [m, setM] = useState([2, 1, 1, 2]); // a b c d

        // Test Vector v
        const [v, setV] = useState({ x: 1, y: 0 });

        const [dragging, setDragging] = useState(false);

        // Calc Av
        const Av = {
          x: m[0] * v.x + m[1] * v.y,
          y: m[2] * v.x + m[3] * v.y,
        };

        // Check Collinearity (Eigen condition)
        // v cross Av = 0
        // Also check if Av is not zero vector (unless lambda is 0, but v cannot be zero)
        const cp = v.x * Av.y - v.y * Av.x;
        const isEigen =
          Math.abs(cp) < 0.5 && (Math.abs(v.x) > 0.1 || Math.abs(v.y) > 0.1); // tolerance

        // Calculate Eigenvalues for display
        // det(M - lambda I) = 0
        // (a-l)(d-l) - bc = 0 => l^2 - (a+d)l + (ad-bc) = 0
        const tr = m[0] + m[3];
        const det = m[0] * m[3] - m[1] * m[2];
        const delta = Math.sqrt(Math.max(0, tr * tr - 4 * det)); // Ensure no NaN
        const l1 = (tr + delta) / 2;
        const l2 = (tr - delta) / 2;

        // Current Scale Factor
        const magV = Math.sqrt(v.x * v.x + v.y * v.y);
        const magAv = Math.sqrt(Av.x * Av.x + Av.y * Av.y);
        // Approximate lambda if eigen
        // lambda = (v . Av) / |v|^2
        const lambdaApprox = (v.x * Av.x + v.y * Av.y) / (magV * magV || 1);

        // Coords
        const w = 600,
          h = 600;
        const range = 6;
        const scale = w / (2 * range);
        const originX = w / 2,
          originY = h / 2;
        const toScreen = (x, y) => ({
          x: originX + x * scale,
          y: originY - y * scale,
        });
        const fromScreen = (sx, sy) => ({
          x: (sx - originX) / scale,
          y: (originY - sy) / scale,
        });

        const handleMouseMove = (e) => {
          if (!dragging) return;
          const rect = e.currentTarget.getBoundingClientRect();
          const pt = fromScreen(e.clientX - rect.left, e.clientY - rect.top);
          // Normalize drag to unit circle ish? No, let them drag freely but maybe cap length
          setV(pt);
        };

        const Arrow = ({ end, color, width, label }) => (
          <g>
            <line
              x1={originX}
              y1={originY}
              x2={toScreen(end.x, end.y).x}
              y2={toScreen(end.x, end.y).y}
              stroke={color}
              strokeWidth={width}
              markerEnd={`url(#head-${color.replace("#", "")})`}
            />
          </g>
        );

        return (
          <div
            className="flex-grow flex flex-col items-center justify-center p-8 select-none"
            onMouseUp={() => setDragging(false)}
          >
            <div className="absolute top-4 right-4">
              <button
                onClick={() => setLang((l) => (l === "en" ? "zh" : "en"))}
                className="px-3 py-1 bg-slate-800 border border-slate-600 rounded-full text-xs font-bold text-emerald-400 hover:bg-slate-700 hover:text-white transition flex items-center gap-2"
              >
                <i className="fa-solid fa-language"></i>
                {t.langBtn}
              </button>
            </div>

            <header className="mb-8 text-center">
              <div className="text-emerald-500 font-bold uppercase tracking-widest text-xs mb-2">
                {t.unit}
              </div>
              <h1 className="text-4xl font-extrabold text-white mb-2">
                {t.title}
              </h1>
              <p className="text-slate-400 font-mono text-lg">{t.subtitle}</p>
            </header>

            <div className="flex flex-col lg:flex-row gap-8 w-full max-w-6xl">
              <div className="flex-1 glass p-6 rounded-3xl relative flex items-center justify-center aspect-square">
                <svg
                  width="100%"
                  height="100%"
                  viewBox="0 0 600 600"
                  className="overflow-visible bg-slate-900 rounded-xl"
                  onMouseMove={handleMouseMove}
                >
                  <defs>
                    <marker
                      id="head-f43f5e"
                      markerWidth="6"
                      markerHeight="6"
                      refX="5"
                      refY="3"
                      orient="auto"
                    >
                      <path d="M0,0 L6,3 L0,6" fill="#f43f5e" />
                    </marker>
                    <marker
                      id="head-10b981"
                      markerWidth="6"
                      markerHeight="6"
                      refX="5"
                      refY="3"
                      orient="auto"
                    >
                      <path d="M0,0 L6,3 L0,6" fill="#10b981" />
                    </marker>
                    <marker
                      id="head-fbbf24"
                      markerWidth="6"
                      markerHeight="6"
                      refX="5"
                      refY="3"
                      orient="auto"
                    >
                      <path d="M0,0 L6,3 L0,6" fill="#fbbf24" />
                    </marker>
                  </defs>

                  <line
                    x1={originX}
                    y1="0"
                    x2={originX}
                    y2={h}
                    stroke="#334155"
                  />
                  <line
                    x1="0"
                    y1={originY}
                    x2={w}
                    y2={originY}
                    stroke="#334155"
                  />
                  <circle
                    cx={originX}
                    cy={originY}
                    r={scale}
                    stroke="#334155"
                    fill="none"
                    strokeDasharray="5,5"
                  />

                  {/* Transformed Vector Av */}
                  <Arrow end={Av} color="#f43f5e" width={isEigen ? 6 : 4} />

                  {/* Input Vector v */}
                  <Arrow end={v} color="#fbbf24" width="4" />
                  <circle
                    cx={toScreen(v.x, v.y).x}
                    cy={toScreen(v.x, v.y).y}
                    r="12"
                    fill={isEigen ? "#10b981" : "#fbbf24"}
                    opacity="0.5"
                    className="draggable"
                    onMouseDown={() => setDragging(true)}
                  />

                  {isEigen && (
                    <text
                      x={w / 2}
                      y={h - 50}
                      textAnchor="middle"
                      fill="#10b981"
                      fontSize="24"
                      fontWeight="bold"
                    >
                      {t.found}
                    </text>
                  )}
                </svg>
              </div>

              <div className="w-full lg:w-96 space-y-6">
                <div className="glass p-6 rounded-2xl">
                  <h3 className="text-lg font-bold text-white mb-4">
                    {t.goal}
                  </h3>
                  <p
                    className="text-sm text-slate-300 mb-4"
                    dangerouslySetInnerHTML={{ __html: t.goalDesc }}
                  ></p>
                  <div className="p-4 bg-slate-800 rounded-xl space-y-2 font-mono text-sm">
                    <div className="flex justify-between">
                      <span className="text-amber-400">v:</span>
                      <span>
                        ({v.x.toFixed(2)}, {v.y.toFixed(2)})
                      </span>
                    </div>
                    <div className="flex justify-between">
                      <span className="text-rose-400">Av:</span>
                      <span>
                        ({Av.x.toFixed(2)}, {Av.y.toFixed(2)})
                      </span>
                    </div>
                    <div className="border-t border-slate-600 my-2"></div>
                    <div className="flex justify-between">
                      <span className="text-blue-400">{t.scale}</span>
                      <span
                        className={
                          isEigen
                            ? "text-emerald-400 font-bold"
                            : "text-slate-500"
                        }
                      >
                        {isEigen ? lambdaApprox.toFixed(2) : "---"}
                      </span>
                    </div>
                  </div>
                </div>

                <div className="glass p-6 rounded-2xl">
                  <h3 className="text-xs font-bold text-slate-400 uppercase mb-2">
                    {t.matrix}
                  </h3>
                  <div className="grid grid-cols-2 gap-4 text-center font-mono text-xl bg-slate-800 p-4 rounded-xl mb-4">
                    <input
                      type="number"
                      value={m[0]}
                      onChange={(e) =>
                        setM([Number(e.target.value), m[1], m[2], m[3]])
                      }
                      className="bg-transparent text-center w-full"
                    />
                    <input
                      type="number"
                      value={m[1]}
                      onChange={(e) =>
                        setM([m[0], Number(e.target.value), m[2], m[3]])
                      }
                      className="bg-transparent text-center w-full"
                    />
                    <input
                      type="number"
                      value={m[2]}
                      onChange={(e) =>
                        setM([m[0], m[1], Number(e.target.value), m[3]])
                      }
                      className="bg-transparent text-center w-full"
                    />
                    <input
                      type="number"
                      value={m[3]}
                      onChange={(e) =>
                        setM([m[0], m[1], m[2], Number(e.target.value)])
                      }
                      className="bg-transparent text-center w-full"
                    />
                  </div>
                  <div className="text-xs text-center text-slate-500">
                    {t.edit}
                  </div>
                </div>

                <div className="text-center text-xs text-slate-600">
                  {t.trueEigen} {l1.toFixed(2)}, {l2.toFixed(2)}
                </div>
              </div>
            </div>
          </div>
        );
      };
      const root = ReactDOM.createRoot(document.getElementById("root"));
      root.render(<App />);
    </script>
  </body>
</html>
