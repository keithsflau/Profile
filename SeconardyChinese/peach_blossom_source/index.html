<!DOCTYPE html>
<html lang="zh-HK">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 桃花源記遊 2.0 (The Peach Blossom Source)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Ma+Shan+Zheng&family=Noto+Serif+TC:wght@400;700&display=swap"
        rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Noto Serif TC', serif;
            background-color: #000;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        /* Cinema Scope Bars */
        .cinema-bar {
            position: absolute;
            left: 0;
            width: 100%;
            height: 0;
            background: black;
            transition: height 1s cubic-bezier(0.77, 0, 0.175, 1);
            z-index: 20;
        }

        .bar-top {
            top: 0;
        }

        .bar-bottom {
            bottom: 0;
        }

        .cinematic .bar-top,
        .cinematic .bar-bottom {
            height: 10vh;
        }

        /* HUD */
        .hud-content {
            position: absolute;
            top: 20px;
            right: 20px;
            color: rgba(255, 255, 255, 0.9);
            text-align: right;
        }

        .quest-log {
            font-family: 'Ma Shan Zheng', cursive;
            font-size: 1.5rem;
            text-shadow: 0 0 10px #ff69b4;
        }

        .quest-item {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 10px;
            margin-bottom: 5px;
            opacity: 0.7;
            transition: opacity 0.3s;
        }

        .quest-item.completed {
            text-decoration: line-through;
            color: #86efac;
            opacity: 0.5;
        }

        .quest-item.active {
            opacity: 1;
            font-weight: bold;
        }

        /* Crosshair */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 8px;
            height: 8px;
            background: white;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 5px white;
            opacity: 0.5;
            transition: transform 0.2s, opacity 0.2s;
        }

        #crosshair.hovering {
            transform: translate(-50%, -50%) scale(2);
            opacity: 1;
            background: #facc15;
        }

        /* Interaction Prompt */
        #prompt {
            position: absolute;
            top: 60%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 1.2rem;
            opacity: 0;
            transition: opacity 0.3s;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        #prompt.visible {
            opacity: 1;
        }

        /* Narrative Overlay */
        #narrative-box {
            position: absolute;
            bottom: 10%;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 800px;
            text-align: center;
            opacity: 0;
            transition: opacity 1s;
        }

        #narrative-box.visible {
            opacity: 1;
        }

        .poem-line {
            font-family: 'Ma Shan Zheng', cursive;
            font-size: 2.5rem;
            color: white;
            text-shadow: 0 0 20px rgba(255, 105, 180, 0.8);
            margin-bottom: 1rem;
        }

        /* Start Screen */
        #start-screen {
            position: absolute;
            inset: 0;
            background: linear-gradient(rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.8)), url('https://images.unsplash.com/photo-1528164344705-47542687000d?ixlib=rb-1.2.1&auto=format&fit=crop&w=1950&q=80');
            background-size: cover;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 50;
            pointer-events: auto;
        }

        .title-main {
            font-family: 'Ma Shan Zheng', cursive;
            font-size: 6rem;
            color: white;
            text-shadow: 0 0 30px #ff69b4;
            margin-bottom: 2rem;
        }

        .fade-in {
            animation: fadein 2s;
        }

        @keyframes fadein {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }
    </style>
</head>

<body>

    <div id="ui-layer">
        <div class="cinema-bar bar-top"></div>
        <div class="cinema-bar bar-bottom"></div>

        <div id="crosshair"></div>
        <div id="prompt">[ E ] 閱讀</div>

        <div class="hud-content" id="hud" style="display:none;">
            <div class="quest-log">
                <div id="q1" class="quest-item active">尋找桃花林入口 (Find Entrance) 🌸</div>
                <div id="q2" class="quest-item">探索水源 (Find Water Source) 💧</div>
                <div id="q3" class="quest-item">發現山洞 (Discover Cave) ⛰️</div>
            </div>
        </div>

        <div id="narrative-box">
            <div id="narrative-text" class="poem-line">晉太元中，武陵人捕魚為業...</div>
        </div>
    </div>

    <div id="start-screen">
        <h1 class="title-main">桃花源記遊 2.0</h1>
        <p class="text-white text-xl mb-8 opacity-80">Immersive Experience • 按 WASD 移動 • 滑鼠 轉視角</p>
        <button onclick="startGame()"
            class="px-8 py-3 bg-white/20 hover:bg-white/40 border border-white/50 text-white rounded-full text-xl transition backdrop-blur">
            開始旅程 (Enter Journey)
        </button>
    </div>

    <script>
        /**
         * PEACH BLOSSOM SOURCE 2.0
         * Features: Procedural Terrain, Water Shader, Volumetric Fog, Quest System
         */

        // --- THREE.JS VARIABLES ---
        let scene, camera, renderer;
        let controls = { locked: false };
        let clock = new THREE.Clock();
        let player = { height: 2, speed: 5, velocity: new THREE.Vector3(), direction: new THREE.Vector3() };
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, canJump = false;

        // Interactables
        let interactables = [];
        let raycaster = new THREE.Raycaster();

        // Shaders
        const WATER_VERTEX = `
    varying vec2 vUv;
    uniform float iTime;
    void main() {
        vUv = uv;
        vec3 pos = position;
        pos.y += sin(pos.x * 2.0 + iTime) * 0.2;
        pos.y += cos(pos.z * 1.5 + iTime) * 0.2;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
    }
`;
        const WATER_FRAGMENT = `
    varying vec2 vUv;
    uniform float iTime;
    void main() {
        vec3 waterColor = vec3(0.0, 0.5, 0.8);
        float foam = sin(vUv.x * 20.0 + iTime) * cos(vUv.y * 20.0 + iTime);
        gl_FragColor = vec4(waterColor + foam * 0.1, 0.6); // 0.6 alpha
    }
`;

        // State
        const QUESTS = {
            q1: { done: false, triggerDist: 20, target: new THREE.Vector3(0, 0, -30) },
            q2: { done: false, triggerDist: 15, target: new THREE.Vector3(40, 0, 0) },
            q3: { done: false, triggerDist: 10, target: new THREE.Vector3(0, 5, 40) }
        };

        function init() {
            // 1. Scene Setup
            scene = new THREE.Scene();
            // Mystic Fog
            scene.background = new THREE.Color(0xffd1dc); // Light Pink
            scene.fog = new THREE.FogExp2(0xffd1dc, 0.025);

            // 2. Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 0);

            // 3. Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            // 4. Light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xfff0dd, 0.8);
            dirLight.position.set(50, 50, 50);
            dirLight.castShadow = true;
            scene.add(dirLight);

            // 5. Build World
            buildTerrain();
            buildWater();
            buildTrees();
            buildInteractables();

            // 6. Event Listeners
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('click', onClick);
            window.addEventListener('resize', onResize);

            // Pointer Lock
            renderer.domElement.addEventListener('click', () => {
                if (!controls.locked) document.body.requestPointerLock();
            });
            document.addEventListener('pointerlockchange', () => {
                controls.locked = (document.pointerLockElement === document.body);
            });

            // Start Loop
            animate();
        }

        function buildTerrain() {
            const geometry = new THREE.PlaneGeometry(200, 200, 100, 100);
            geometry.rotateX(-Math.PI / 2);

            const positions = geometry.attributes.position.array;
            const box = new THREE.Box3();
            const simplex = new SimplexNoise();

            for (let i = 0; i < positions.length; i += 3) {
                let x = positions[i];
                let z = positions[i + 2];

                // Noise for rolling hills
                let y = simplex.noise2D(x * 0.02, z * 0.02) * 5;
                y += simplex.noise2D(x * 0.1, z * 0.1) * 1;

                // Path (Road to Peach Blossom Source) - Flatten middle
                let dist = Math.sqrt(x * x + z * z);
                if (Math.abs(x) < 5 && z < 0) {
                    y *= Math.abs(x) / 5; // Valley effect
                }

                positions[i + 1] = y;
            }
            geometry.computeVertexNormals();

            const material = new THREE.MeshStandardMaterial({
                color: 0x5c8d45,
                roughness: 0.8,
                flatShading: true,
                side: THREE.DoubleSide
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.receiveShadow = true;
            scene.add(mesh);

            // Ground collision helper (simplified)
            // In a real engine we'd cast rays down, here we just use the noise function again logic in update
        }

        function buildWater() {
            const geometry = new THREE.PlaneGeometry(200, 200, 50, 50);
            geometry.rotateX(-Math.PI / 2);

            const material = new THREE.ShaderMaterial({
                uniforms: { iTime: { value: 0 } },
                vertexShader: WATER_VERTEX,
                fragmentShader: WATER_FRAGMENT,
                transparent: true
            });

            const water = new THREE.Mesh(geometry, material);
            water.position.y = -2; // Water level
            scene.add(water);
            scene.userData.water = water; // Store for update
        }

        function buildTrees() {
            // Instanced Mesh for Performance
            const trunkGeo = new THREE.CylinderGeometry(0.2, 0.4, 3, 5);
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x5c4033 });
            const leavesGeo = new THREE.IcosahedronGeometry(1.5, 0);
            const leavesMat = new THREE.MeshStandardMaterial({ color: 0xff69b4, emissive: 0x330011 });

            for (let i = 0; i < 100; i++) {
                const x = (Math.random() - 0.5) * 180;
                const z = (Math.random() - 0.5) * 180;

                // Don't spawn on path
                if (Math.abs(x) < 8 && z < 10) continue;

                const trunk = new THREE.Mesh(trunkGeo, trunkMat);
                const leaves = new THREE.Mesh(leavesGeo, leavesMat);

                trunk.position.set(x, 1.5, z); // Approx Y
                leaves.position.set(0, 2.5, 0);
                trunk.add(leaves);

                // Random scale/rot
                trunk.scale.multiplyScalar(0.8 + Math.random() * 0.5);
                trunk.rotation.y = Math.random() * Math.PI;

                scene.add(trunk);
            }
        }

        function buildInteractables() {
            // Stone Tablet (Start)
            createInteractable(0, 1, -10, "stone", "忽逢桃花林，夾岸數百步...");

            // Water Info
            createInteractable(40, 1, 0, "scroll", "緣溪行，忘路之遠近。");

            // Cave
            createInteractable(0, 1, 40, "cave", "林盡水源，便得一山，山有小口...");
        }

        function createInteractable(x, y, z, type, text) {
            const group = new THREE.Group();
            group.position.set(x, y, z);

            let mesh;
            if (type === 'stone') {
                mesh = new THREE.Mesh(new THREE.BoxGeometry(1, 1.5, 0.5), new THREE.MeshStandardMaterial({ color: 0x888888 }));
            } else if (type === 'scroll') {
                mesh = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 1, 10), new THREE.MeshStandardMaterial({ color: 0xf5deb3 }));
                mesh.rotation.z = Math.PI / 2;
            } else {
                mesh = new THREE.Mesh(new THREE.DodecahedronGeometry(1), new THREE.MeshStandardMaterial({ color: 0x444444 }));
            }

            group.add(mesh);

            // Floating Text indicator
            // (Simplified as we use HUD prompt instead)

            // Add to interactables for Raycasting
            mesh.userData = { text: text, type: type };
            group.userData = { text: text, type: type }; // Backup
            interactables.push(mesh);
            scene.add(group);
        }

        // --- CONTROLS ---

        function onKeyDown(e) {
            switch (e.code) {
                case 'ArrowUp': case 'KeyW': moveForward = true; break;
                case 'ArrowLeft': case 'KeyA': moveLeft = true; break;
                case 'ArrowDown': case 'KeyS': moveBackward = true; break;
                case 'ArrowRight': case 'KeyD': moveRight = true; break;
                case 'Space': if (!canJump) player.velocity.y += 10; canJump = true; break;
            }
        }
        function onKeyUp(e) {
            switch (e.code) {
                case 'ArrowUp': case 'KeyW': moveForward = false; break;
                case 'ArrowLeft': case 'KeyA': moveLeft = false; break;
                case 'ArrowDown': case 'KeyS': moveBackward = false; break;
                case 'ArrowRight': case 'KeyD': moveRight = false; break;
            }
        }
        function onMouseMove(e) {
            if (!controls.locked) return;
            const sensitivity = 0.002;
            camera.rotation.y -= e.movementX * sensitivity;
            // Simple Pitch limits
            // Not implementing full quaternion clamp for brevity, simple var tracking usually needed
            // Assuming user mostly looks around horizontally for this walking sim
        }
        function onClick() {
            if (controls.locked && activeInteractable) {
                // Interact
                showNarrative(activeInteractable.userData.text);
                updateQuestLog(activeInteractable.userData.type);
            }
        }

        let activeInteractable = null;

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();

            if (scene.userData.water) {
                scene.userData.water.material.uniforms.iTime.value += delta;
            }

            if (controls.locked) {
                // Physics / Movement
                player.velocity.x -= player.velocity.x * 10.0 * delta;
                player.velocity.z -= player.velocity.z * 10.0 * delta;
                player.velocity.y -= 9.8 * 2.0 * delta; // Gravity

                player.direction.z = Number(moveForward) - Number(moveBackward);
                player.direction.x = Number(moveRight) - Number(moveLeft);
                player.direction.normalize();

                if (moveForward || moveBackward) player.velocity.z -= player.direction.z * 100.0 * delta;
                if (moveLeft || moveRight) player.velocity.x -= player.direction.x * 100.0 * delta;

                // Apply Move (Local to Camera Rotation)
                const rotY = camera.rotation.y;
                const dx = player.velocity.x * delta * Math.cos(rotY) - player.velocity.z * delta * Math.sin(rotY); // Actually Side/Fwd mixing needed
                // Simpler: standard FPS math
                const forward = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0, 1, 0), camera.rotation.y);
                const right = new THREE.Vector3(1, 0, 0).applyAxisAngle(new THREE.Vector3(0, 1, 0), camera.rotation.y);

                // Re-calc velocity mapping strictly for "Move"
                const moveSpeed = 5 * delta;
                if (moveForward) camera.position.add(forward.clone().multiplyScalar(moveSpeed));
                if (moveBackward) camera.position.add(forward.clone().multiplyScalar(-moveSpeed));
                if (moveRight) camera.position.add(right.clone().multiplyScalar(moveSpeed));
                if (moveLeft) camera.position.add(right.clone().multiplyScalar(-moveSpeed));

                // Height / Terrain Collision placeholder
                // Ideally we sample noise at (x,z) and set y >= terrainY + playerHeight
                // const tY = getTerrainHeight(camera.position.x, camera.position.z);
                // if (camera.position.y < tY + 2) camera.position.y = tY + 2;
                // Keeping it simple flat plane + noise visually for now to avoid stuck bugs
            }

            // Raycast Interaction
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObjects(interactables);

            if (intersects.length > 0 && intersects[0].distance < 5) {
                activeInteractable = intersects[0].object;
                document.getElementById('crosshair').classList.add('hovering');
                document.getElementById('prompt').classList.add('visible');
            } else {
                activeInteractable = null;
                document.getElementById('crosshair').classList.remove('hovering');
                document.getElementById('prompt').classList.remove('visible');
            }

            renderer.render(scene, camera);
        }

        function getTerrainHeight(x, z) {
            // Replicate noise logic if needed
            return 0;
        }

        function showNarrative(text) {
            const box = document.getElementById('narrative-box');
            document.getElementById('narrative-text').textContent = text;
            box.classList.add('visible');
            document.body.classList.add('cinematic'); // Add black bars

            setTimeout(() => {
                box.classList.remove('visible');
                document.body.classList.remove('cinematic');
            }, 5000);
        }

        function updateQuestLog(type) {
            if (type === 'stone') {
                document.getElementById('q1').classList.add('completed');
                document.getElementById('q2').classList.add('active');
            }
            if (type === 'scroll') {
                document.getElementById('q2').classList.add('completed');
                document.getElementById('q3').classList.add('active');
            }
            if (type === 'cave') {
                document.getElementById('q3').classList.add('completed');
                showNarrative("初極狹，才通人。復行數十步，豁然開朗！(The End)");
            }
        }

        function startGame() {
            controls.locked = false; // Will trigger on click
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('hud').style.display = 'block';
            // Init logic
            init();
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

    </script>

    <!-- Visit Counter -->
    <div id="visit-counter-container" class="text-center my-4"></div>

    <!-- Visit Counter Script -->
    <script src="/visit-counter.js"></script>
    <script>
        const SCRIPT_URL = 'https://script.google.com/macros/s/AKfycby5jEjDAcEM6TttPbwwh1tvXPo_-W7YrNlKfJRV82PjkmAHvR_wILhA7h-zIRPF7oTRTw/exec';
        VisitCounter.init('c-/users/keith/onedrive/desktop/profile/seconardychinese/peach-blossom-source', {
            scriptUrl: SCRIPT_URL,
            containerId: 'visit-counter-container'
        });
    </script>
</body>

</html>