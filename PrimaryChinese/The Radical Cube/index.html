<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Radical Cube - Final</title>
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <script type="importmap">
        {
            "imports": {
                "react": "https://esm.sh/react@18.2.0",
                "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
                "three": "https://esm.sh/three@0.149.0",
                "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.13.0?external=react,react-dom,three",
                "@react-three/drei": "https://esm.sh/@react-three/drei@9.60.0?external=react,react-dom,three,@react-three/fiber"
            }
        }
    </script>

    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        body, html { margin: 0; padding: 0; height: 100%; overflow: hidden; background-color: #0f172a; }
        #root { width: 100%; height: 100%; }
        
        @keyframes floatUp {
            0% { opacity: 1; transform: translate(-50%, -50%) scale(0.5); }
            50% { transform: translate(-50%, -100%) scale(1.2); }
            100% { opacity: 0; transform: translate(-50%, -150%) scale(1); }
        }
        .match-effect {
            position: absolute;
            left: 50%;
            top: 50%;
            pointer-events: none;
            animation: floatUp 1.5s ease-out forwards;
            font-weight: bold;
            text-shadow: 0 0 20px rgba(255,215,0, 0.8);
            z-index: 10;
        }

        /* 提示按鈕動畫 */
        @keyframes pulse-green {
            0%, 100% { box-shadow: 0 0 0 0 rgba(74, 222, 128, 0.7); transform: scale(1); }
            50% { box-shadow: 0 0 0 10px rgba(74, 222, 128, 0); transform: scale(1.05); }
        }
        .hint-pulse {
            animation: pulse-green 2s infinite;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useRef, useMemo, useEffect } from 'react';
        import { createRoot } from 'react-dom/client';
        import * as THREE from 'three';
        import { Canvas, useFrame } from '@react-three/fiber';
        import { OrbitControls, Stars, Sparkles } from '@react-three/drei';

        // --- Game Logic (簡單字庫 & 雙向索引) ---
        const RAW_COMBINATIONS = [
            { pair: ["女", "子"], result: "好" },
            { pair: ["日", "月"], result: "明" },
            { pair: ["木", "寸"], result: "村" },
            { pair: ["十", "口"], result: "古" },
            { pair: ["女", "口"], result: "如" },  
            { pair: ["日", "十"], result: "早" }, 
            { pair: ["口", "木"], result: "杏" }, 
            { pair: ["木", "木"], result: "林" }, 
            { pair: ["口", "口"], result: "回" }, 
            { pair: ["口", "寸"], result: "吋" }, 
            { pair: ["口", "天"], result: "吞" }, 
            { pair: ["門", "口"], result: "問" },
            { pair: ["火", "山"], result: "炭" }
        ];

        // 產生雙向對應表 (A,B 和 B,A 都有效)
        const COMBINATIONS = {};
        RAW_COMBINATIONS.forEach(combo => {
            COMBINATIONS[combo.pair.join(',')] = combo.result;
            COMBINATIONS[combo.pair.slice().reverse().join(',')] = combo.result;
        });

        const RADICAL_POOL = ["木", "寸", "女", "子", "口", "十", "日", "月", "門", "天", "火", "山"];
        const INITIAL_FACES = ["女", "子", "木", "寸", "口", "十"];

        // --- Texture Generator (支援提示顏色) ---
        function createCharacterTexture(char, isSelected, isError, isSuccess, isHint) {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // Background Color logic
            if (isSuccess) ctx.fillStyle = '#F59E0B'; // Gold
            else if (isError) ctx.fillStyle = '#ef4444'; // Red
            else if (isSelected) ctx.fillStyle = '#2563eb'; // Blue
            else if (isHint) ctx.fillStyle = '#059669'; // Green (Hint)
            else ctx.fillStyle = '#1e293b'; // Slate 800
            
            ctx.fillRect(0, 0, 512, 512);

            // Border
            ctx.strokeStyle = (isSelected || isHint) ? '#ffffff' : '#475569';
            ctx.lineWidth = isHint ? 30 : 20;
            ctx.strokeRect(0, 0, 512, 512);

            // Text
            ctx.font = 'bold 260px "Microsoft YaHei", "SimHei", sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = isSuccess ? '#ffffff' : ((isSelected || isHint) ? '#ffffff' : '#e2e8f0');
            ctx.fillText(char, 256, 256);

            // Marker
            ctx.fillStyle = 'rgba(255,255,255,0.1)';
            ctx.beginPath();
            ctx.arc(40, 40, 10, 0, Math.PI*2);
            ctx.fill();

            return new THREE.CanvasTexture(canvas);
        }

        // --- 3D Components ---
        const FaceMaterial = ({ char, index, selectedFaces, status, hintFaces }) => {
            const isSelected = selectedFaces.includes(index);
            // 只有未被選中且在提示列表中的面才顯示綠色
            const isHint = hintFaces.includes(index) && !isSelected;
            
            let isError = false;
            let isSuccess = false;
            
            if (isSelected && status === 'error') isError = true;
            if (isSelected && status === 'success') isSuccess = true;

            const texture = useMemo(() => {
                return createCharacterTexture(char, isSelected, isError, isSuccess, isHint);
            }, [char, isSelected, isError, isSuccess, isHint]);

            // 定義發光顏色
            const emissiveColor = isSuccess ? "#F59E0B" : (isHint ? "#059669" : (isSelected ? "#3b82f6" : "#000000"));

            return (
                <meshStandardMaterial 
                    attach={`material-${index}`} 
                    map={texture}
                    emissive={new THREE.Color(emissiveColor)}
                    emissiveIntensity={isSuccess || isHint ? 0.6 : (isSelected ? 0.5 : 0)}
                    roughness={0.2}
                    metalness={0.1}
                />
            );
        };

        const PuzzleCube = ({ faces, selectedFaces, onFaceClick, status, hintFaces }) => {
            const meshRef = useRef();

            useFrame((state, delta) => {
                if (meshRef.current && selectedFaces.length === 0) {
                    meshRef.current.rotation.x += delta * 0.05;
                    meshRef.current.rotation.y += delta * 0.08;
                }
            });

            return (
                <mesh 
                    ref={meshRef}
                    // Size 3 as requested (大方塊)
                    onClick={(e) => {
                        e.stopPropagation();
                        if (e.face.materialIndex !== undefined && status === 'idle') {
                            onFaceClick(e.face.materialIndex);
                        }
                    }}
                >
                    <boxGeometry args={[3, 3, 3]} />
                    {faces.map((char, i) => (
                        <FaceMaterial 
                            key={`${i}-${char}`} 
                            index={i} 
                            char={char} 
                            selectedFaces={selectedFaces}
                            status={status}
                            hintFaces={hintFaces}
                        />
                    ))}
                </mesh>
            );
        };

        // --- Main Game Component ---
        const Game = () => {
            const [faces, setFaces] = useState(INITIAL_FACES);
            const [selectedFaces, setSelectedFaces] = useState([]); 
            const [score, setScore] = useState(0);
            const [status, setStatus] = useState('idle'); 
            const [lastMatch, setLastMatch] = useState(null); 
            const [hintFaces, setHintFaces] = useState([]); // 新增：提示狀態

            // 當玩家開始選擇時，清除提示
            useEffect(() => {
                if (selectedFaces.length > 0) {
                    setHintFaces([]);
                }
            }, [selectedFaces]);

            const handleFaceClick = (index) => {
                if (status !== 'idle') return;

                if (selectedFaces.includes(index)) {
                    setSelectedFaces(selectedFaces.filter(i => i !== index));
                    return;
                }

                if (selectedFaces.length < 2) {
                    const newSelection = [...selectedFaces, index];
                    setSelectedFaces(newSelection);

                    if (newSelection.length === 2) {
                        checkMatch(newSelection);
                    }
                }
            };

            const checkMatch = (indices) => {
                setStatus('checking');
                const charA = faces[indices[0]];
                const charB = faces[indices[1]];
                
                // 直接查表 (無需排序，因為我們在初始化時雙向都存了)
                const key = `${charA},${charB}`;
                const result = COMBINATIONS[key];

                if (result) {
                    setStatus('success');
                    setTimeout(() => {
                        setScore(s => s + 1);
                        setLastMatch({ char: result, id: Date.now() });
                        
                        const newFaces = [...faces];
                        newFaces[indices[0]] = RADICAL_POOL[Math.floor(Math.random() * RADICAL_POOL.length)];
                        newFaces[indices[1]] = RADICAL_POOL[Math.floor(Math.random() * RADICAL_POOL.length)];
                        setFaces(newFaces);

                        setSelectedFaces([]);
                        setStatus('idle');
                    }, 800);
                } else {
                    setStatus('error');
                    setTimeout(() => {
                        setSelectedFaces([]);
                        setStatus('idle');
                    }, 800);
                }
            };

            // 提示邏輯
            const triggerHint = () => {
                // 暴力檢查目前面上的所有組合
                for (let i = 0; i < faces.length; i++) {
                    for (let j = i + 1; j < faces.length; j++) {
                        const key = `${faces[i]},${faces[j]}`;
                        if (COMBINATIONS[key]) {
                            setHintFaces([i, j]); // 標記這兩個面
                            return; 
                        }
                    }
                }
                alert("目前畫面上沒有可以配對的組合，請試著隨便配對一組來換新字！");
            };

            return (
                <div className="relative w-full h-full">
                    {/* Camera Z position at 7 to fit Big Cube */}
                    <Canvas camera={{ position: [0, 0, 7], fov: 50 }}>
                        <color attach="background" args={['#0f172a']} />
                        
                        <ambientLight intensity={0.8} />
                        <pointLight position={[10, 10, 10]} intensity={1.5} />
                        <pointLight position={[-10, -10, -10]} intensity={0.5} />
                        
                        <Stars radius={100} depth={50} count={5000} factor={4} saturation={0} fade speed={1} />
                        <Sparkles count={50} scale={5} size={4} speed={0.4} opacity={0.5} color="#cbd5e1" />

                        <PuzzleCube 
                            faces={faces} 
                            selectedFaces={selectedFaces} 
                            onFaceClick={handleFaceClick}
                            status={status}
                            hintFaces={hintFaces}
                        />

                        <OrbitControls enablePan={false} enableZoom={false} minPolarAngle={Math.PI/4} maxPolarAngle={Math.PI - Math.PI/4} />
                    </Canvas>

                    {/* UI Layer */}
                    <div className="absolute top-0 left-0 w-full p-6 pointer-events-none flex justify-between items-start">
                        <div>
                            <h1 className="text-4xl font-bold text-white tracking-wider mb-2" style={{textShadow: '0 2px 10px rgba(0,0,0,0.5)'}}>
                                <span className="text-blue-400">漢字</span>方塊
                            </h1>
                            <p className="text-slate-400 text-sm max-w-xs">
                                點擊兩個部首組成漢字<br/>
                                <span className="text-xs opacity-70">例如: 女 + 子 = 好</span>
                            </p>
                        </div>
                        <div className="text-right">
                            <div className="text-6xl font-black text-white" style={{textShadow: '0 2px 10px rgba(0,0,0,0.5)'}}>{score}</div>
                            <div className="text-blue-400 uppercase tracking-widest text-sm">Matches</div>
                        </div>
                    </div>

                    {lastMatch && (
                        <div key={lastMatch.id} className="match-effect text-8xl text-yellow-400">
                            {lastMatch.char}
                        </div>
                    )}

                    {/* 提示按鈕 (右下角) */}
                    <div className="absolute bottom-24 right-6 z-20">
                        <button 
                            onClick={triggerHint}
                            className="bg-white/10 hover:bg-white/20 text-yellow-400 p-4 rounded-full backdrop-blur-md transition-all active:scale-95 border border-white/10 shadow-lg group hint-pulse"
                            title="顯示提示"
                        >
                            <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                                <path d="M9 18h6"></path>
                                <path d="M10 22h4"></path>
                                <path d="M12 2v1"></path>
                                <path d="M12 7v5"></path>
                                <path d="M12 13h.01"></path>
                                <path d="M21 13a9 9 0 0 0-9-9 9 9 0 0 0-9 9c0 2.488 1.01 4.735 2.635 6.364L6 20a2 2 0 0 0 2 2h8a2 2 0 0 0 2-2l1.365-1.636A9 9 0 0 0 21 13z"></path>
                            </svg>
                        </button>
                    </div>

                    {/* 狀態列 */}
                    <div className="absolute bottom-10 w-full text-center pointer-events-none px-4">
                        {status === 'error' && <span className="text-red-500 font-bold bg-black/80 px-6 py-3 rounded-full shadow-lg border border-red-900/50 backdrop-blur-sm animate-bounce inline-block">配對失敗 (Try again)</span>}
                        {status === 'success' && <span className="text-yellow-400 font-bold bg-black/80 px-6 py-3 rounded-full shadow-lg border border-yellow-900/50 backdrop-blur-sm inline-block">配對成功!</span>}
                        {status === 'idle' && hintFaces.length > 0 && <span className="text-green-400 font-bold bg-black/80 px-6 py-3 rounded-full shadow-lg border border-green-900/50 backdrop-blur-sm inline-block">提示：試試綠色的方塊！</span>}
                        {status === 'idle' && selectedFaces.length === 1 && <span className="text-blue-300 bg-black/80 px-6 py-3 rounded-full shadow-lg border border-blue-900/50 backdrop-blur-sm inline-block">請選擇另一個...</span>}
                    </div>
                </div>
            );
        };

        const root = createRoot(document.getElementById('root'));
        root.render(<Game />);
    </script>

    <!-- Visit Counter -->
    <div id="visit-counter-container" class="text-center my-4"></div>

    <!-- Visit Counter Script -->
    <script src="/visit-counter.js"></script>
    <script>
        const SCRIPT_URL = 'https://script.google.com/macros/s/AKfycby5jEjDAcEM6TttPbwwh1tvXPo_-W7YrNlKfJRV82PjkmAHvR_wILhA7h-zIRPF7oTRTw/exec';
        VisitCounter.init('c-/users/keith/onedrive/desktop/profile/primarychinese/the-radical-cube', {
            scriptUrl: SCRIPT_URL,
            containerId: 'visit-counter-container'
        });
    </script>
</body>
</html>