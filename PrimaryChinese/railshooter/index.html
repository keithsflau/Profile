<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>èªæ³•é£›è»Š (Grammar Coaster)</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #050510; font-family: "Microsoft JhengHei", "Heiti TC", sans-serif; }
        .hud-text { text-shadow: 0 0 10px rgba(0, 255, 255, 0.8); }
        
        /* éœ‡å‹•æ•ˆæœ */
        @keyframes shake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            10% { transform: translate(-1px, -2px) rotate(-1deg); }
            20% { transform: translate(-3px, 0px) rotate(1deg); }
            30% { transform: translate(3px, 2px) rotate(0deg); }
            40% { transform: translate(1px, -1px) rotate(1deg); }
            50% { transform: translate(-1px, 2px) rotate(-1deg); }
            60% { transform: translate(-3px, 1px) rotate(0deg); }
            70% { transform: translate(3px, 1px) rotate(-1deg); }
            80% { transform: translate(-1px, -1px) rotate(1deg); }
            90% { transform: translate(1px, 2px) rotate(0deg); }
            100% { transform: translate(1px, -2px) rotate(-1deg); }
        }
        .shake-effect { animation: shake 0.5s; }
        
        .glitch-overlay { background: rgba(255, 0, 0, 0.3); mix-blend-mode: overlay; }
        .success-overlay { background: rgba(0, 255, 0, 0.2); mix-blend-mode: overlay; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- éŠæˆ²å¹³è¡¡è¨­å®š ---
        const INITIAL_SPEED = 0.08;   
        const SPEED_INCREMENT = 0.005; 
        const SPEED_DECREMENT = 0.02;  
        const MIN_SPEED = 0.05;       
        const MAX_LIVES = 2;          
        
        // é–˜é–€é–“è· (ä¿æŒé•·è·é›¢)
        const GATE_SPACING = 120; 

        const QUESTIONS = [
            { sentence: "_______ ä¸‹é›¨ï¼Œæ‰€ä»¥æ¯”è³½å–æ¶ˆã€‚", correct: "å› ç‚º", wrong: "é›–ç„¶" },
            { sentence: "_______ ä»–å¾ˆåŠªåŠ›ï¼Œä½†æ˜¯è€ƒè©¦é‚„æ˜¯ä¸åŠæ ¼ã€‚", correct: "é›–ç„¶", wrong: "ä¸ä½†" },
            { sentence: "é€™æœ¬æ›¸ _______ æœ‰è¶£ï¼Œè€Œä¸”å¾ˆæœ‰æ•™è‚²æ„ç¾©ã€‚", correct: "ä¸ä½†", wrong: "åªè¦" },
            { sentence: "_______ ä½ è‚¯åŠªåŠ›ï¼Œå°±ä¸€å®šæœƒæˆåŠŸã€‚", correct: "åªè¦", wrong: "å³ä½¿" },
            { sentence: "_______ å¤©æ°£å¾ˆå†·ï¼Œä»–é‚„æ˜¯å …æŒå»æ¸¸æ³³ã€‚", correct: "å³ä½¿", wrong: "ç‚ºäº†" },
            { sentence: "ä»– _______ åšå®Œäº†ä½œæ¥­ï¼Œé‚„é ç¿’äº†æ˜å¤©çš„åŠŸèª²ã€‚", correct: "ä¸åƒ…", wrong: "å¦‚æœ" },
            { sentence: "_______ æ˜å¤©ä¸ä¸‹é›¨ï¼Œæˆ‘å€‘å°±å»é‡é¤ã€‚", correct: "å¦‚æœ", wrong: "æ—¢ç„¶" },
            { sentence: "_______ ä½ å·²ç¶“æ±ºå®šäº†ï¼Œæˆ‘å°±ä¸å†å¤šèªªã€‚", correct: "æ—¢ç„¶", wrong: "é™¤é" },
            { sentence: "_______ æ²’äººåå°ï¼Œæˆ‘å€‘å°±é€™æ¨£æ±ºå®šå§ã€‚", correct: "æ—¢ç„¶", wrong: "è¦æ˜¯" },
            { sentence: "é€™ä»¶è¡£æœ _______ æ¼‚äº®ï¼Œè€Œä¸”åƒ¹æ ¼ä¾¿å®œã€‚", correct: "ä¸ä½†", wrong: "å¯§å¯" }
        ];

        // --- 2D æ–‡å­—è½‰è²¼åœ– (å·¨å‹åŒ–å„ªåŒ–) ---
        function createTextTexture(text, color = '#00ffff') {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            // åŠ å¤§ Canvas è§£æåº¦ä»¥ç¢ºä¿æ”¾å¤§å¾Œä¸æ¨¡ç³Š
            canvas.width = 1024;
            canvas.height = 512;
            
            // èƒŒæ™¯æ¡†
            ctx.fillStyle = 'rgba(0,0,0,0.8)'; // æ›´é»‘ä¸€é»ï¼Œå°æ¯”æ›´é«˜
            ctx.fillRect(20, 20, 984, 472);
            
            // é‚Šæ¡†
            ctx.strokeStyle = color;
            ctx.lineWidth = 30; // é‚Šæ¡†åŠ ç²—
            ctx.strokeRect(20, 20, 984, 472);

            // æ–‡å­— (æ¥µå¤§)
            ctx.font = 'bold 300px "Microsoft JhengHei", "Heiti TC", sans-serif'; // å­—é«”æ¥µå¤§åŒ–
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = '#ffffff';
            ctx.fillText(text, 512, 256);
            
            // ç™¼å…‰æ•ˆæœ
            ctx.shadowColor = color;
            ctx.shadowBlur = 50;
            ctx.fillText(text, 512, 256);

            return new THREE.CanvasTexture(canvas);
        }

        const Game = () => {
            const [gameState, setGameState] = useState('START');
            const [score, setScore] = useState(0);
            const [lives, setLives] = useState(MAX_LIVES);
            const [speedDisplay, setSpeedDisplay] = useState(0);
            const [currentQuestion, setCurrentQuestion] = useState(null);
            const [feedback, setFeedback] = useState(null); 
            
            const mountRef = useRef(null);
            
            // Three.js Refs
            const sceneRef = useRef(null);
            const cameraRef = useRef(null);
            const playerRef = useRef(null);
            const gatesRef = useRef([]);
            const speedRef = useRef(INITIAL_SPEED);
            const laneRef = useRef(0); 
            const scoreRef = useRef(0);
            const livesRef = useRef(MAX_LIVES);
            const questionIndexRef = useRef(0);

            useEffect(() => {
                if (!mountRef.current) return;

                // 1. åˆå§‹åŒ–å ´æ™¯
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0x050510);
                // [ä¿®æ”¹] éœ§æ°£è®Šå¾—æ¥µæ·¡ï¼Œç‚ºäº†èƒ½åœ¨é è™•çœ‹æ¸…å¤§å­—
                scene.fog = new THREE.FogExp2(0x050510, 0.008); 
                sceneRef.current = scene;

                const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                // ç›¸æ©Ÿç¨å¾®æ‹‰é«˜ä¸€é»ï¼Œé¿å…è¢«å·¨å¤§çš„é–˜é–€é®æ“‹è¦–ç·š
                camera.position.set(0, 4, 7); 
                cameraRef.current = camera;

                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                mountRef.current.appendChild(renderer.domElement);

                // 2. ç‡ˆå…‰
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
                scene.add(ambientLight);
                const dirLight = new THREE.DirectionalLight(0xff00ff, 1.2);
                dirLight.position.set(0, 20, 10);
                scene.add(dirLight);

                // 3. åœ°é¢èˆ‡è·‘é“ç·š
                const gridHelper = new THREE.GridHelper(200, 100, 0x555555, 0x111111);
                gridHelper.position.y = -1;
                scene.add(gridHelper);
                
                const lineGeo = new THREE.PlaneGeometry(0.15, 200); // ç·šç¨å¾®åŠ ç²—
                const lineMat = new THREE.MeshBasicMaterial({ color: 0x444444 });
                
                const leftLine = new THREE.Mesh(lineGeo, lineMat);
                leftLine.rotation.x = -Math.PI / 2;
                leftLine.position.set(-1, -0.98, -50);
                scene.add(leftLine);

                const rightLine = new THREE.Mesh(lineGeo, lineMat);
                rightLine.rotation.x = -Math.PI / 2;
                rightLine.position.set(1, -0.98, -50);
                scene.add(rightLine);

                // 4. ç©å®¶
                const geometry = new THREE.ConeGeometry(0.5, 1.5, 4); 
                const material = new THREE.MeshPhongMaterial({ color: 0x00ffff, emissive: 0x002266, flatShading: true });
                const player = new THREE.Mesh(geometry, material);
                player.rotation.x = -Math.PI / 2;
                player.rotation.y = Math.PI / 4; 
                scene.add(player);
                playerRef.current = player;
                
                const engine = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), new THREE.MeshBasicMaterial({ color: 0x00ffff }));
                engine.position.y = -0.5;
                player.add(engine);

                // 5. é–˜é–€ç”Ÿæˆ (å·¨å‹åŒ–)
                const spawnGate = (zPos, qIndex) => {
                    const question = QUESTIONS[qIndex % QUESTIONS.length];
                    const isLeftCorrect = Math.random() > 0.5;
                    const leftText = isLeftCorrect ? question.correct : question.wrong;
                    const rightText = isLeftCorrect ? question.wrong : question.correct;
                    const correctLane = isLeftCorrect ? -1 : 1;

                    const gateGroup = new THREE.Group();
                    gateGroup.position.z = zPos;
                    gateGroup.userData = { type: 'gate', correctLane: correctLane, processed: false, questionIndex: qIndex };

                    // [ä¿®æ”¹] æ”¯æŸ±: åŠ é«˜åŠ ç²—
                    const poleGeo = new THREE.BoxGeometry(0.3, 10, 0.3); // é«˜åº¦ç”± 5 -> 10
                    const poleMat = new THREE.MeshBasicMaterial({ color: 0xff00ff, wireframe: true });
                    
                    // ç‚ºäº†è®“è»Šå­é€šéï¼Œæ”¯æŸ±éœ€è¦å¾€å…©å´ç§»é–‹ä¸€é»é»
                    const lPole1 = new THREE.Mesh(poleGeo, poleMat); lPole1.position.set(-3.5, 4, 0);
                    const lPole2 = new THREE.Mesh(poleGeo, poleMat); lPole2.position.set(-0.5, 4, 0);
                    
                    const rPole1 = new THREE.Mesh(poleGeo, poleMat); rPole1.position.set(0.5, 4, 0);
                    const rPole2 = new THREE.Mesh(poleGeo, poleMat); rPole2.position.set(3.5, 4, 0);
                    
                    // [ä¿®æ”¹] æ–‡å­—æ¿: å·¨å‹åŒ–
                    // åŸæœ¬ 2.2 x 1.1 -> ç¾åœ¨ 3.0 x 1.8ï¼Œéå¸¸å¤§
                    const planeGeo = new THREE.PlaneGeometry(3.0, 1.8); 
                    
                    const lSign = new THREE.Mesh(planeGeo, new THREE.MeshBasicMaterial({ map: createTextTexture(leftText, '#00ffff'), transparent: true }));
                    lSign.position.set(-2, 4.5, 0); // ä½ç½®æ‹‰é«˜ï¼Œå°æ‡‰æ”¯æŸ±
                    
                    const rSign = new THREE.Mesh(planeGeo, new THREE.MeshBasicMaterial({ map: createTextTexture(rightText, '#00ffff'), transparent: true }));
                    rSign.position.set(2, 4.5, 0); 

                    // é ‚éƒ¨è£é£¾æ¢
                    const topBarGeo = new THREE.BoxGeometry(3.2, 0.2, 0.2);
                    const topBarMat = new THREE.MeshBasicMaterial({ color: 0x00ffff });
                    const lTop = new THREE.Mesh(topBarGeo, topBarMat); lTop.position.set(-2, 9, 0);
                    const rTop = new THREE.Mesh(topBarGeo, topBarMat); rTop.position.set(2, 9, 0);

                    gateGroup.add(lPole1, lPole2, rPole1, rPole2, lSign, rSign, lTop, rTop);
                    scene.add(gateGroup);
                    gatesRef.current.push(gateGroup);
                };

                // åˆå§‹ç”Ÿæˆ
                for(let i=0; i<3; i++) {
                    spawnGate(-60 - (i * GATE_SPACING), i); 
                }
                setCurrentQuestion(QUESTIONS[0]);

                // --- å‹•ç•«å¾ªç’° ---
                let animationId;
                const animate = () => {
                    animationId = requestAnimationFrame(animate);

                    if (gameState !== 'PLAYING') return;

                    const currentSpeed = speedRef.current;
                    setSpeedDisplay(Math.floor(currentSpeed * 300)); 

                    // 1. å‰é€²
                    player.position.z -= currentSpeed;
                    
                    // 2. é¡é ­è·Ÿéš¨
                    camera.position.z = player.position.z + 7; // è·Ÿéš¨è·é›¢
                    camera.position.x = player.position.x * 0.4;

                    // ç¶²æ ¼ç§»å‹•
                    const gridZ = Math.floor(player.position.z / 10) * 10;
                    gridHelper.position.z = gridZ;
                    leftLine.position.z = player.position.z - 50; 
                    rightLine.position.z = player.position.z - 50;

                    // 3. ç©å®¶å·¦å³ç§»å‹•
                    const targetX = laneRef.current * 2; 
                    player.position.x += (targetX - player.position.x) * 0.1; 
                    player.rotation.z = -(player.position.x - targetX) * 0.3; 

                    // 4. é–˜é–€åˆ¤å®š
                    gatesRef.current.forEach((gate, index) => {
                        const distZ = gate.position.z - player.position.z;
                        
                        if (Math.abs(distZ) < 0.5 && !gate.userData.processed) {
                            gate.userData.processed = true;
                            
                            let playerLane = 0;
                            if (player.position.x < -1) playerLane = -1;
                            else if (player.position.x > 1) playerLane = 1;

                            if (playerLane === gate.userData.correctLane) {
                                scoreRef.current += 100;
                                speedRef.current += SPEED_INCREMENT;
                                setScore(scoreRef.current);
                                setFeedback('HIT');
                                setTimeout(() => setFeedback(null), 500);
                            } else {
                                livesRef.current -= 1;
                                setLives(livesRef.current);
                                speedRef.current = Math.max(MIN_SPEED, speedRef.current - SPEED_DECREMENT);
                                
                                setFeedback('MISS');
                                setTimeout(() => setFeedback(null), 500);

                                if (livesRef.current <= 0) {
                                    setGameState('GAME_OVER');
                                }
                            }

                            const nextQIndex = gate.userData.questionIndex + 1;
                            const nextQ = QUESTIONS[nextQIndex % QUESTIONS.length];
                            setCurrentQuestion(nextQ);
                        }

                        // å›æ”¶
                        if (distZ > 20) { // ç¨å¾®æ™šä¸€é»ç§»é™¤ï¼Œå› ç‚ºé–˜é–€å¾ˆå¤§
                            scene.remove(gate);
                            gatesRef.current.splice(index, 1);
                            
                            const lastGateZ = gatesRef.current[gatesRef.current.length-1].position.z;
                            spawnGate(lastGateZ - GATE_SPACING, questionIndexRef.current + 3); 
                            questionIndexRef.current++;
                        }
                    });

                    renderer.render(scene, camera);
                };

                animate();

                const handleResize = () => {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                };
                window.addEventListener('resize', handleResize);

                return () => {
                    cancelAnimationFrame(animationId);
                    window.removeEventListener('resize', handleResize);
                    mountRef.current.removeChild(renderer.domElement);
                };
            }, [gameState]);

            useEffect(() => {
                const handleKeyDown = (e) => {
                    if (gameState !== 'PLAYING') return;
                    if (e.key === 'ArrowLeft') laneRef.current = -1;
                    else if (e.key === 'ArrowRight') laneRef.current = 1;
                };
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [gameState]);

            const startGame = () => {
                scoreRef.current = 0;
                livesRef.current = MAX_LIVES;
                speedRef.current = INITIAL_SPEED;
                laneRef.current = 0;
                questionIndexRef.current = 0;
                
                setScore(0);
                setLives(MAX_LIVES);
                setGameState('PLAYING');
            };

            return (
                <div className="relative w-full h-screen overflow-hidden text-white select-none">
                    <div ref={mountRef} className={`w-full h-full ${feedback === 'MISS' ? 'shake-effect' : ''}`}/>

                    {gameState === 'PLAYING' && (
                        <>
                            {feedback === 'HIT' && <div className="absolute inset-0 success-overlay transition-opacity duration-300"></div>}
                            {feedback === 'MISS' && <div className="absolute inset-0 glitch-overlay transition-opacity duration-300"></div>}

                            <div className="absolute top-4 left-4 font-mono text-xl hud-text">
                                <div className="text-cyan-400">é€Ÿåº¦: {speedDisplay} km/h</div>
                                <div className="text-yellow-400">å¾—åˆ†: {score}</div>
                                <div className="mt-2 text-3xl">
                                    {Array(lives).fill('â¤ï¸').join('')}
                                    {Array(MAX_LIVES - lives).fill('ğŸ–¤').join('')}
                                </div>
                            </div>

                            <div className="absolute bottom-10 left-1/2 transform -translate-x-1/2 w-3/4 md:w-1/2 bg-black/70 border border-cyan-500 p-6 rounded-lg backdrop-blur-sm text-center">
                                <h2 className="text-gray-400 text-sm mb-2 tracking-widest uppercase">é¡Œç›®</h2>
                                <p className="text-2xl md:text-4xl font-bold text-white hud-text py-2">
                                    {currentQuestion ? currentQuestion.sentence : "æº–å‚™ä¸­..."}
                                </p>
                                <div className="mt-2 flex justify-between text-xl text-cyan-300 font-bold">
                                    <span>&lt; å·¦</span>
                                    <span>å³ &gt;</span>
                                </div>
                            </div>
                        </>
                    )}

                    {gameState === 'GAME_OVER' && (
                        <div className="absolute inset-0 flex flex-col items-center justify-center bg-black/90 z-50">
                            <h1 className="text-6xl font-black text-red-500 mb-4 glitch-text">ä»»å‹™å¤±æ•—</h1>
                            <p className="text-2xl text-white mb-8">æœ€çµ‚å¾—åˆ†: <span className="text-yellow-400">{score}</span></p>
                            <button onClick={startGame} className="px-8 py-4 bg-cyan-600 hover:bg-cyan-500 text-white font-bold rounded text-xl shadow-lg">
                                å†æ¬¡æŒ‘æˆ°
                            </button>
                        </div>
                    )}

                    {gameState === 'START' && (
                        <div className="absolute inset-0 flex flex-col items-center justify-center bg-black/90 z-50">
                            <h1 className="text-6xl md:text-8xl font-black text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-purple-500 mb-8 hud-text">
                                èªæ³•é£›è»Š
                            </h1>
                            <div className="text-center space-y-4 max-w-lg">
                                <p className="text-xl text-gray-300">å·¦å³ç§»å‹•ï¼Œè¡ç ´æ­£ç¢ºçš„é€£æ¥è©ï¼</p>
                                <div className="flex justify-center space-x-2 text-2xl">
                                    {Array(MAX_LIVES).fill('â¤ï¸').join('')}
                                </div>
                                <p className="text-red-400 text-sm">åªæœ‰ {MAX_LIVES} æ¬¡æ©Ÿæœƒï¼Œé€Ÿåº¦æœƒè¶Šä¾†è¶Šå¿«ï¼</p>
                                <button onClick={startGame} className="px-8 py-4 bg-cyan-600 hover:bg-cyan-500 text-white font-bold rounded text-xl transform hover:scale-105 transition-all">
                                    å•Ÿå‹•å¼•æ“
                                </button>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<Game />);
    </script>
</body>
</html>