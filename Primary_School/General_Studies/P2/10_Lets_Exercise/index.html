<!DOCTYPE html>
<html lang="zh-HK">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>å°äºŒå¸¸è­˜ï¼šé‹å‹•èº«é«”å¥½ | Let's Exercise</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/framer-motion@10.16.4/dist/framer-motion.js"></script>
    <script src="../../common/i18n.js"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700;900&family=Fredoka:wght@400;600&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        font-family: "Fredoka", "Noto Sans TC", sans-serif;
        background: linear-gradient(135deg, #fef08a 0%, #facc15 100%);
        touch-action: none; /* Prevent scroll on mobile game */
      }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <script type="text/babel">
      const { useState, useEffect, useRef } = React;
      const { motion, AnimatePresence } = window.Motion;
      const { LanguageSelector, get } = window.MathI18n;

      const t = {
        title: {
          en: "Let's Exercise!",
          zh: "é‹å‹•èº«é«”å¥½",
          ja: "é‹å‹•ã—ã‚ˆã†ï¼",
        },
        instruction: {
          en: "Catch sports gear! Avoid junk food!",
          zh: "æ¥ä½é‹å‹•ç”¨å“ï¼é¿é–‹é›¶é£Ÿï¼",
          ja: "ã‚¹ãƒãƒ¼ãƒ„ç”¨å…·ã‚’ã‚­ãƒ£ãƒƒãƒï¼ã‚¸ãƒ£ãƒ³ã‚¯ãƒ•ãƒ¼ãƒ‰ã¯é¿ã‘ã¦ï¼",
        },
        start: { en: "Start", zh: "é–‹å§‹" },
        score: { en: "Score", zh: "åˆ†æ•¸" },
        time: { en: "Time", zh: "æ™‚é–“" },
        gameover: { en: "Game Over", zh: "éŠæˆ²çµæŸ" },
        final: { en: "Final Score", zh: "æœ€çµ‚åˆ†æ•¸" },
        restart: { en: "Play Again", zh: "å†ç©ä¸€æ¬¡" },
      };

      const GOOD_ITEMS = ["ğŸ€", "âš½", "ğŸ¸", "ğŸ¾", "ğŸ“"];
      const BAD_ITEMS = ["ğŸ”", "ğŸŸ", "ğŸ¥¤", "ğŸ©", "ğŸ¬"];

      const GAME_WIDTH = 100; // Percent
      const PLAYER_WIDTH = 20; // Percent relative to container width? Actually let's use pixels roughly or %
      // Let's use % for responsive

      function App() {
        const [lang, setLang] = useState("zh");
        const [isPlaying, setIsPlaying] = useState(false);
        const [score, setScore] = useState(0);
        const [timeLeft, setTimeLeft] = useState(30);
        const [playerX, setPlayerX] = useState(50); // % 0-100 center
        const [items, setItems] = useState([]); // { id, x, y, icon, type }
        const [gameOver, setGameOver] = useState(false);

        const requestRef = useRef();
        const lastSpawnRef = useRef(0);
        const containerRef = useRef(null);

        const getText = (key) => t[key][lang] || t[key]["en"];

        // Game Loop
        const update = (time) => {
          if (!isPlaying) return;

          // Spawn
          if (time - lastSpawnRef.current > 800) {
            // spawn rate
            spawnItem();
            lastSpawnRef.current = time;
          }

          // Move Items
          setItems((prevItems) => {
            const nextItems = [];
            for (let item of prevItems) {
              const nextY = item.y + 1.5; // Speed

              // Collision Check
              if (nextY > 85 && nextY < 95 && Math.abs(item.x - playerX) < 10) {
                // Catch
                if (item.type === "good") setScore((s) => s + 10);
                else setScore((s) => Math.max(0, s - 20)); // Penalty
                // Don't add to nextItems (remove)
              } else if (nextY >= 100) {
                // Missed
                // If good missed, maybe no penalty or small? Let's just ignore.
              } else {
                nextItems.push({ ...item, y: nextY });
              }
            }
            return nextItems;
          });

          requestRef.current = requestAnimationFrame(update);
        };

        const spawnItem = () => {
          const isGood = Math.random() > 0.4; // 60% good
          const type = isGood ? "good" : "bad";
          const icon = isGood
            ? GOOD_ITEMS[Math.floor(Math.random() * GOOD_ITEMS.length)]
            : BAD_ITEMS[Math.floor(Math.random() * BAD_ITEMS.length)];

          setItems((prev) => [
            ...prev,
            {
              id: Date.now() + Math.random(),
              x: Math.random() * 80 + 10, // 10-90%
              y: -10,
              icon,
              type,
            },
          ]);
        };

        useEffect(() => {
          if (isPlaying) {
            requestRef.current = requestAnimationFrame(update);
            const timer = setInterval(() => {
              setTimeLeft((t) => {
                if (t <= 1) {
                  setIsPlaying(false);
                  setGameOver(true);
                  cancelAnimationFrame(requestRef.current);
                  return 0;
                }
                return t - 1;
              });
            }, 1000);
            return () => {
              cancelAnimationFrame(requestRef.current);
              clearInterval(timer);
            };
          }
        }, [isPlaying, playerX]); // Dependency on playerX is risky for loop but OK if ref based?
        // Actually referencing state inside requestAnimationFrame closure is stale.
        // Need to use Refs for game state or functional updates.
        // I used functional update for setItems/setScore so that's safe.
        // BUT playerX collision check inside setItem functional update needs to be fresh?
        // Items update logic doesn't see latest playerX if closure is old.
        // FIX: Use a ref for playerX.

        const playerXRef = useRef(playerX);
        useEffect(() => {
          playerXRef.current = playerX;
        }, [playerX]);

        // Rewrite loop to use ref for collision
        const updateFixed = (time) => {
          if (!isPlaying) return;

          if (time - lastSpawnRef.current > 600) {
            const isGood = Math.random() > 0.4;
            const type = isGood ? "good" : "bad";
            const icon = isGood
              ? GOOD_ITEMS[Math.floor(Math.random() * GOOD_ITEMS.length)]
              : BAD_ITEMS[Math.floor(Math.random() * BAD_ITEMS.length)];
            setItems((prev) => [
              ...prev,
              {
                id: Math.random(),
                x: Math.random() * 80 + 10,
                y: -10,
                icon,
                type,
              },
            ]);
            lastSpawnRef.current = time;
          }

          setItems((prev) => {
            const currentX = playerXRef.current;
            return prev.filter((item) => {
              const nextY = item.y + 0.8 + (30 - timeLeft) / 30; // Speed up slightly over time?

              // Collision Y range: Player is around 85-95%
              if (nextY > 80 && nextY < 95) {
                if (Math.abs(item.x - currentX) < 12) {
                  // Hit
                  if (item.type === "good") setScore((s) => s + 10);
                  else setScore((s) => Math.max(0, s - 20));
                  return false; // Remove
                }
              }
              if (nextY > 100) return false;
              item.y = nextY;
              return true; // Keep
            }); // Mutation of item.y? Better map new obj but perf penalty... simple mutation for frame logic ok in react if strict mode off? Let's map.
            // Actually better:
            /*
                 return prev.map(item => ({...item, y: item.y+1}))
                            .filter(...)
                 */
          });
          requestRef.current = requestAnimationFrame(updateFixed);
        };

        // Let's use simpler logic:
        // Just rely on the useEffect dependency? No, that restarts loop.
        // Standard game loop pattern: useRef for everything mutable.

        // Re-implementing simplified loop hook
        useEffect(() => {
          if (isPlaying)
            requestRef.current = requestAnimationFrame(updateFixed);
          return () => cancelAnimationFrame(requestRef.current);
        }, [isPlaying]);

        const handleMove = (e) => {
          if (!containerRef.current || !isPlaying) return;
          // Touch or Mouse
          const clientX = e.touches ? e.touches[0].clientX : e.clientX;
          const rect = containerRef.current.getBoundingClientRect();
          let x = ((clientX - rect.left) / rect.width) * 100;
          x = Math.max(0, Math.min(100, x));
          setPlayerX(x);
        };

        const startGame = () => {
          setScore(0);
          setTimeLeft(30);
          setItems([]);
          setIsPlaying(true);
          setGameOver(false);
          lastSpawnRef.current = performance.now();
        };

        return (
          <div className="min-h-screen p-4 flex flex-col items-center overflow-hidden overscroll-none">
            <LanguageSelector lang={lang} setLang={setLang} />
            <h1 className="text-4xl md:text-5xl font-black text-yellow-900 mb-4 mt-8 drop-shadow-sm bg-white/50 px-6 py-2 rounded-full z-10">
              ğŸƒ {getText("title")}
            </h1>

            {/* Game Container */}
            <div
              ref={containerRef}
              className="relative w-full max-w-md h-[60vh] bg-white rounded-3xl shadow-xl overflow-hidden border-4 border-yellow-300 touch-none cursor-crosshair"
              onMouseMove={handleMove}
              onTouchMove={handleMove}
            >
              {/* Background Decor */}
              <div className="absolute inset-0 bg-yellow-50 opacity-50"></div>
              <div className="absolute bottom-0 w-full h-[10%] bg-green-400"></div>

              {/* HUD */}
              <div className="absolute top-4 left-4 right-4 flex justify-between font-black text-xl z-20">
                <div className="bg-white/80 px-4 py-1 rounded-full shadow text-yellow-800">
                  {getText("score")}: {score}
                </div>
                <div className="bg-white/80 px-4 py-1 rounded-full shadow text-red-600">
                  â±ï¸ {Math.ceil(timeLeft)}
                </div>
              </div>

              {/* Items */}
              {items.map((item) => (
                <div
                  key={item.id}
                  className="absolute text-4xl transform -translate-x-1/2 -translate-y-1/2 will-change-transform"
                  style={{ left: `${item.x}%`, top: `${item.y}%` }}
                >
                  {item.icon}
                </div>
              ))}

              {/* Player */}
              <div
                className="absolute bottom-[10%] text-6xl transform -translate-x-1/2 will-change-transform transition-transform duration-75"
                style={{ left: `${playerX}%` }}
              >
                ğŸ§’
              </div>

              {/* Overlay for start/end */}
              {!isPlaying && (
                <div className="absolute inset-0 bg-black/40 backdrop-blur-sm flex flex-col items-center justify-center z-30">
                  <div className="bg-white p-8 rounded-3xl shadow-2xl text-center">
                    {gameOver ? (
                      <>
                        <div className="text-6xl mb-2">ğŸ</div>
                        <h2 className="text-3xl font-black text-yellow-800 mb-2">
                          {getText("gameover")}
                        </h2>
                        <p className="text-2xl font-bold mb-6">
                          {getText("final")}: {score}
                        </p>
                        <button
                          onClick={startGame}
                          className="bg-yellow-500 text-white px-8 py-3 rounded-full font-black text-xl hover:bg-yellow-600 shadow-xl"
                        >
                          {getText("restart")} ğŸ”„
                        </button>
                      </>
                    ) : (
                      <>
                        <h2 className="text-2xl font-black text-yellow-800 mb-4">
                          {getText("instruction")}
                        </h2>
                        <button
                          onClick={startGame}
                          className="bg-green-500 text-white px-10 py-4 rounded-full font-black text-2xl hover:bg-green-600 shadow-xl border-b-4 border-green-700 active:border-b-0 active:translate-y-1"
                        >
                          {getText("start")} â–¶ï¸
                        </button>
                      </>
                    )}
                  </div>
                </div>
              )}
            </div>

            <p className="mt-4 font-bold text-slate-500 text-sm md:text-base text-center w-full max-w-md">
              (Mouse/Touch to Move)
            </p>
          </div>
        );
      }
      ReactDOM.createRoot(document.getElementById("root")).render(<App />);
    </script>
  
      
      <!-- Footer -->
      <footer class="text-center py-4 text-slate-500 text-sm">
        <p class="italic mb-1">
          But God made the earth by his power; he founded the world by his wisdom and stretched out the heavens by his
          understanding. Jeremiah 10:12
        </p>
        <p class="text-xs mb-1 mt-2">
          ã€Œè€¶å’Œè¯ç”¨èƒ½åŠ›å‰µé€ å¤§åœ°ï¼Œç”¨æ™ºæ…§å»ºç«‹ä¸–ç•Œï¼Œç”¨è°æ˜é‹ªå¼µç©¹è’¼ã€‚ã€ è€¶åˆ©ç±³æ›¸ 10:12
        </p>
        <p class="text-xs mt-2 pt-2 border-t border-slate-300">
          @ 2025 Education Engineering Portfolio | Generated by Gemini Pro 3.0 | Prepared by SF Lau
        </p>
      </footer>
</body>
</html>
