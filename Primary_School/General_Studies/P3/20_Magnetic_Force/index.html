<!DOCTYPE html>
<html lang="zh-HK">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>å°ä¸‰å¸¸è­˜ï¼šç£åŠ›è¿·å®® | Magnetic Force</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/framer-motion@10.16.4/dist/framer-motion.js"></script>
    <script src="../../common/i18n.js"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700;900&family=Fredoka:wght@400;600&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        font-family: "Fredoka", "Noto Sans TC", sans-serif;
        background: radial-gradient(circle at center, #fca5a5 0%, #dc2626 100%);
        touch-action: none; /* Prevent scroll on touch for maze */
      }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <script type="text/babel">
      const { useState, useEffect, useRef } = React;
      const { motion, AnimatePresence } = window.Motion;
      const { LanguageSelector, get } = window.MathI18n;

      const t = {
        title: {
          en: "Magnetic Force",
          zh: "ç£åŠ›è¿·å®®",
          ja: "ç£åŠ›è¿·è·¯",
          ko: "ìê¸°ë ¥ ë¯¸ë¡œ",
          es: "Fuerza MagnÃ©tica",
          de: "Magnetkraft",
          fi: "Magneettinen voima",
          fr: "Force magnÃ©tique",
          ar: "Ø§Ù„Ù‚ÙˆØ© Ø§Ù„Ù…ØºÙ†Ø§Ø·ÙŠØ³ÙŠØ©",
          it: "Forza Magnetica",
        },
        instruction: {
          en: "Guide the ball with the magnet!",
          zh: "ç”¨ç£çŸ³å¼•é ˜éµç åŠé¿é–‹éšœç¤™ï¼",
          ja: "ç£çŸ³ã§ãƒœãƒ¼ãƒ«ã‚’å°ã“ã†ï¼",
          ko: "ìì„ìœ¼ë¡œ ê³µì„ ì•ˆë‚´í•˜ì„¸ìš”!",
          es: "Â¡GuÃ­a la bola con el imÃ¡n!",
          de: "FÃ¼hre den Ball mit dem Magneten!",
          fi: "Ohjaa palloa magneetilla!",
          fr: "Guidez la balle avec l'aimant !",
          ar: "ÙˆØ¬Ù‡ Ø§Ù„ÙƒØ±Ø© Ø¨Ø§Ù„Ù…ØºÙ†Ø§Ø·ÙŠØ³!",
          it: "Guida la palla con il magnete!",
        },

        start: {
          en: "Start",
          zh: "é–‹å§‹",
          ja: "ã‚¹ã‚¿ãƒ¼ãƒˆ",
          ko: "ì‹œì‘",
          es: "Comenzar",
          de: "Start",
          fi: "Aloita",
          fr: "DÃ©marrer",
          ar: "Ø§Ø¨Ø¯Ø£",
          it: "Inizia",
        },
        reset: {
          en: "Reset",
          zh: "é‡ç½®",
          ja: "ãƒªã‚»ãƒƒãƒˆ",
          ko: "ì´ˆê¸°í™”",
          es: "Reiniciar",
          de: "ZurÃ¼cksetzen",
          fi: "Nollaa",
          fr: "RÃ©initialiser",
          ar: "Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ†",
          it: "Reimposta",
        },
        win: {
          en: "Maze Solved!",
          zh: "è¿·å®®ç ´è§£ï¼",
          ja: "è¿·è·¯ã‚¯ãƒªã‚¢ï¼",
          ko: "ë¯¸ë¡œ í•´ê²°!",
          es: "Â¡Laberinto Resuelto!",
          de: "Labyrinth gelÃ¶st!",
          fi: "Sokkelo ratkaistu!",
          fr: "Labyrinthe rÃ©solu !",
          ar: "ØªÙ… Ø­Ù„ Ø§Ù„Ù…ØªØ§Ù‡Ø©!",
          it: "Labirinto Risolto!",
        },
        fail: {
          en: "Oops! Hit Obstacle!",
          zh: "å“å‘€ï¼æ’åˆ°äº†éšœç¤™ç‰©ï¼",
          ja: "ãŠã£ã¨ï¼éšœå®³ç‰©ã«å½“ãŸã£ãŸï¼",
          ko: "ì•„ì´ì¿ ! ì¥ì• ë¬¼ì— ë¶€ë”ªí˜”ì–´ìš”!",
          es: "Â¡Ups! Â¡Chocaste con un obstÃ¡culo!",
          de: "Hoppla! Hindernis getroffen!",
          fi: "Hups! Osui esteeseen!",
          fr: "Oups ! Obstacle touchÃ© !",
          ar: "Ø£ÙˆØ¨Ø³! Ø§ØµØ·Ø¯Ù…Øª Ø¨Ø¹Ø§Ø¦Ù‚!",
          it: "Ops! Colpito ostacolo!",
        },
        retry: {
          en: "Try Again",
          zh: "å†è©¦ä¸€æ¬¡",
          ja: "ã‚‚ã†ä¸€åº¦",
          ko: "ë‹¤ì‹œ ì‹œë„",
          es: "Intentar de nuevo",
          de: "Versuch es nochmal",
          fi: "YritÃ¤ uudelleen",
          fr: "RÃ©essayez",
          ar: "Ø­Ø§ÙˆÙ„ Ù…Ø±Ø© Ø£Ø®Ø±Ù‰",
          it: "Riprova",
        },

        attract: {
          en: "Attract",
          zh: "å¸å¼•",
          ja: "å¼•ãã¤ã‘ã‚‹",
          ko: "ë‹¹ê¸°ê¸°",
          es: "Atraer",
          de: "Anziehen",
          fi: "VetÃ¤Ã¤ puoleensa",
          fr: "Attirer",
          ar: "Ø¬Ø°Ø¨",
          it: "Attrarre",
        },
        repel: {
          en: "Repel",
          zh: "æ’æ–¥",
          ja: "åç™ºã™ã‚‹",
          ko: "ë°€ì–´ë‚´ê¸°",
          es: "Repeler",
          de: "AbstoÃŸen",
          fi: "HylkiÃ¤",
          fr: "Repousser",
          ar: "ØªÙ†Ø§ÙØ±",
          it: "Respingere",
        },
      };

      // Maze definition (simple grid for P3)
      // 0: Path, 1: Wall (Wood - No stick but block), 2: Danger (Magnet repel?), 3: Goal
      const mazeGrid = [
        [1, 1, 1, 1, 1, 1, 1, 1],
        [1, 0, 0, 0, 0, 1, 3, 1],
        [1, 0, 1, 1, 0, 1, 0, 1],
        [1, 0, 0, 1, 0, 0, 0, 1],
        [1, 1, 0, 1, 1, 1, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1],
      ];

      function App() {
        const [lang, setLang] = useState("zh");
        const [ballPos, setBallPos] = useState({ x: 1, y: 5 }); // Grid coords
        const [magnetPos, setMagnetPos] = useState({ x: 0, y: 0 }); // Screen px
        const [gameState, setGameState] = useState("playing"); // playing, win, fail

        const mazeRef = useRef(null);
        const ballRef = useRef(null);

        const getText = (key) => t[key][lang] || t[key]["en"];

        // Mouse/Touch tracking for Magnet
        useEffect(() => {
          const handleMove = (e) => {
            if (gameState !== "playing") return;
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            setMagnetPos({ x: clientX, y: clientY });
          };
          window.addEventListener("mousemove", handleMove);
          window.addEventListener("touchmove", handleMove);
          return () => {
            window.removeEventListener("mousemove", handleMove);
            window.removeEventListener("touchmove", handleMove);
          };
        }, [gameState]);

        // Physics Loop (Magnetic Pull)
        useEffect(() => {
          if (gameState !== "playing" || !mazeRef.current) return;

          const interval = setInterval(() => {
            if (!ballRef.current) return;

            const ballRect = ballRef.current.getBoundingClientRect();
            const ballCenter = {
              x: ballRect.left + ballRect.width / 2,
              y: ballRect.top + ballRect.height / 2,
            };

            // Vector to magnet
            const dx = magnetPos.x - ballCenter.x;
            const dy = magnetPos.y - ballCenter.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < 150) {
              // Range
              // Simplistic movement: move towards magnet if valid path
              // We check projected new position
              const speed = 5; // px per tick
              const moveX = (dx / dist) * speed;
              const moveY = (dy / dist) * speed;

              // Convert back to grid roughly to check bounds
              // This is tricky with px vs grid. Let's purely visual + simple bounds check
              // Or keep grid logic strict.
              // For P3, let's just make the ball follow magnet but stop at walls.

              // Actually, let's just use CSS translation relative to container
              // Easier: Ball tracks magnet with lag, checks collision with walls defined by divs.

              // Let's stick to Grid Logic for simplicity of collision
              // But allow smooth movement between cells? Too complex for simple App.
              // Let's make it Discrete: Magnet is cursor. If magnet is close to adjacent cell, move there.

              const cellSize = mazeRef.current.clientWidth / 8; // 8 cols
              const gridX = Math.floor(
                (ballCenter.x - mazeRef.current.getBoundingClientRect().left) /
                  cellSize
              );
              const gridY = Math.floor(
                (ballCenter.y - mazeRef.current.getBoundingClientRect().top) /
                  cellSize
              );

              // Find target direction
              let targetX = gridX;
              let targetY = gridY;

              if (Math.abs(dx) > Math.abs(dy)) {
                targetX += dx > 0 ? 1 : -1;
              } else {
                targetY += dy > 0 ? 1 : -1;
              }

              // Bounds check
              if (
                targetY >= 0 &&
                targetY < mazeGrid.length &&
                targetX >= 0 &&
                targetX < mazeGrid[0].length
              ) {
                const cell = mazeGrid[targetY][targetX];
                if (cell !== 1) {
                  // Not wall
                  // Move visual ball position by updating state (smoothly via CSS transition)
                  // But wait, state is Grid Coords.
                  // Let's implement cooldown to prevent instant teleport
                  setBallPos({ x: targetX, y: targetY });

                  if (cell === 3) setGameState("win");
                }
              }
            }
          }, 200); // 5fps for grid movement

          return () => clearInterval(interval);
        }, [magnetPos, gameState]);

        const reset = () => {
          setBallPos({ x: 1, y: 5 });
          setGameState("playing");
        };

        return (
          <div className="min-h-screen p-4 flex flex-col items-center select-none font-sans overflow-hidden cursor-none">
            <LanguageSelector lang={lang} setLang={setLang} />

            {/* Magnet Cursor Follower */}
            <div
              className="fixed pointer-events-none z-50 text-6xl drop-shadow-2xl transition-transform duration-75"
              style={{
                left: magnetPos.x,
                top: magnetPos.y,
                transform: "translate(-50%, -50%) rotate(-45deg)",
              }}
            >
              ğŸ§²
            </div>

            <h1 className="text-4xl md:text-5xl font-black text-white mb-2 mt-8 drop-shadow-md z-10">
              ğŸ§² {getText("title")}
            </h1>
            <p className="text-white font-bold mb-8 bg-black/20 px-8 py-2 rounded-full text-xl">
              {getText("instruction")}
            </p>

            <div
              className="relative bg-white p-4 rounded-xl shadow-2xl border-8 border-slate-800 w-full max-w-2xl aspect-[8/7]"
              ref={mazeRef}
            >
              {/* Grid Render */}
              <div className="grid grid-rows-7 grid-cols-8 h-full w-full gap-1">
                {mazeGrid.map((row, y) =>
                  row.map((cell, x) => (
                    <div
                      key={`${x}-${y}`}
                      className={`rounded-md flex items-center justify-center
                                ${
                                  cell === 1
                                    ? "bg-amber-800 shadow-inner"
                                    : "bg-slate-100"
                                }
                                ${
                                  cell === 3 ? "bg-green-400 animate-pulse" : ""
                                }
                            `}
                    >
                      {cell === 1 && (
                        <div className="w-full h-full opacity-30 bg-[url('https://www.transparenttextures.com/patterns/wood-pattern.png')]"></div>
                      )}
                      {cell === 3 && <div className="text-3xl">ğŸš©</div>}
                    </div>
                  ))
                )}
              </div>

              {/* Ball */}
              <div
                ref={ballRef}
                className="absolute transition-all duration-300 ease-linear shadow-xl rounded-full bg-gradient-to-br from-gray-300 to-gray-500 border-2 border-gray-600 flex items-center justify-center text-xs font-bold text-white z-20"
                style={{
                  width: "10%",
                  height: "12%", // Roughly grid cell size
                  left: `${ballPos.x * 12.5 + 1.25}%`, // 100/8 = 12.5
                  top: `${ballPos.y * 14.28 + 1}%`, // 100/7 = 14.28
                }}
              >
                <div className="w-2/3 h-2/3 bg-white/30 rounded-full blur-[1px] absolute top-1 right-1"></div>
              </div>

              {gameState === "win" && (
                <motion.div
                  initial={{ scale: 0 }}
                  animate={{ scale: 1 }}
                  className="absolute inset-0 bg-black/80 flex flex-col items-center justify-center text-center z-50 rounded-lg text-white"
                >
                  <div className="text-8xl mb-4">ğŸ‰</div>
                  <h2 className="text-5xl font-black mb-8 text-green-400">
                    {getText("win")}
                  </h2>
                  <button
                    onClick={reset}
                    className="bg-green-500 hover:bg-green-600 text-white font-black text-3xl px-12 py-6 rounded-full shadow-xl transition-transform hover:scale-105 cursor-pointer pointer-events-auto"
                  >
                    {getText("reset")} ğŸ”„
                  </button>
                </motion.div>
              )}
            </div>

            <div className="mt-8 text-white/80 font-bold text-center">
              Move your mouse (or finger) to move the magnet! <br /> Close
              distance attracts the ball!
            </div>
          </div>
        );
      }
      ReactDOM.createRoot(document.getElementById("root")).render(<App />);
    </script>
  
      
      <!-- Footer -->
      <footer class="text-center py-4 text-slate-500 text-sm">
        <p class="italic mb-1">
          But God made the earth by his power; he founded the world by his wisdom and stretched out the heavens by his
          understanding. Jeremiah 10:12
        </p>
        <p class="text-xs mb-1 mt-2">
          ã€Œè€¶å’Œè¯ç”¨èƒ½åŠ›å‰µé€ å¤§åœ°ï¼Œç”¨æ™ºæ…§å»ºç«‹ä¸–ç•Œï¼Œç”¨è°æ˜é‹ªå¼µç©¹è’¼ã€‚ã€ è€¶åˆ©ç±³æ›¸ 10:12
        </p>
        <p class="text-xs mt-2 pt-2 border-t border-slate-300">
          @ 2025 Education Engineering Portfolio | Generated by Gemini Pro 3.0 | Prepared by SF Lau
        </p>
      </footer>
</body>
</html>
