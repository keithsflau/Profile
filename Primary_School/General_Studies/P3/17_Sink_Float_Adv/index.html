<!DOCTYPE html>
<html lang="zh-HK">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Â∞è‰∏âÂ∏∏Ë≠òÔºöÊ≤âËàáÊµÆ (ÈÄ≤Èöé) | Sink or Float Adv</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/framer-motion@10.16.4/dist/framer-motion.js"></script>
    <script src="../../common/i18n.js"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700;900&family=Fredoka:wght@400;600&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        font-family: "Fredoka", "Noto Sans TC", sans-serif;
        background: radial-gradient(circle at center, #bfdbfe 0%, #3b82f6 100%);
      }
    </style>
  </head>
  <body>
    <div id="root"></div>
    <script type="text/babel">
      const { useState, useEffect } = React;
      const { motion, AnimatePresence } = window.Motion;
      const { LanguageSelector, get } = window.MathI18n;

      const t = {
        title: {
          en: "Sink or Float?",
          zh: "Ê≤âÈÇÑÊòØÊµÆÔºü",
          ja: "Ê≤à„ÇÄÔºüÊµÆ„ÅèÔºü",
          ko: "Í∞ÄÎùºÏïâÏùÑÍπåÏöî Îú∞ÍπåÏöî?",
          es: "¬øSe hunde o flota?",
          de: "Sinken oder Schwimmen?",
          fi: "Uppoaako vai kelluuko?",
          fr: "Coule ou flotte ?",
          ar: "Ÿäÿ∫ÿ±ŸÇ ÿ£ŸÖ Ÿäÿ∑ŸÅŸàÿü",
          it: "Affonda o Galleggia?",
        },
        instruction: {
          en: "Predict then Test!",
          zh: "ÂÖàÈ†êÊ∏¨ÔºåÂæåÊ∏¨Ë©¶ÔºÅ",
          ja: "‰∫àÊ∏¨„Åó„Å¶„Åã„Çâ„ÉÜ„Çπ„ÉàÔºÅ",
          ko: "ÏòàÏ∏°ÌïòÍ≥† ÌÖåÏä§Ìä∏ÌïòÏÑ∏Ïöî!",
          es: "¬°Predice y luego prueba!",
          de: "Vorhersagen, dann testen!",
          fi: "Ennusta ja testaa!",
          fr: "Pr√©disez puis testez !",
          ar: "ÿ™ŸàŸÇÿπ ÿ´ŸÖ ÿßÿÆÿ™ÿ®ÿ±!",
          it: "Prevedi e poi Test!",
        },

        sink: {
          en: "Sink",
          zh: "Ê≤â",
          ja: "Ê≤à„ÇÄ",
          ko: "Í∞ÄÎùºÏïâÎã§",
          es: "Hundirse",
          de: "Sinken",
          fi: "Upota",
          fr: "Couler",
          ar: "Ÿäÿ∫ÿ±ŸÇ",
          it: "Affondare",
        },
        float: {
          en: "Float",
          zh: "ÊµÆ",
          ja: "ÊµÆ„Åè",
          ko: "Îú®Îã§",
          es: "Flotar",
          de: "Schwimmen",
          fi: "Kellua",
          fr: "Flotter",
          ar: "Ÿäÿ∑ŸÅŸà",
          it: "Galleggiare",
        },

        predict: {
          en: "Will it float?",
          zh: "ÂÆÉÊúÉÊµÆÂóéÔºü",
          ja: "ÊµÆ„Åç„Åæ„Åô„ÅãÔºü",
          ko: "Îú∞ÍπåÏöî?",
          es: "¬øFlotar√°?",
          de: "Wird es schwimmen?",
          fi: "Kelluuko se?",
          fr: "Est-ce qu'il flottera ?",
          ar: "ŸáŸÑ ÿ≥Ÿäÿ∑ŸÅŸàÿü",
          it: "Gallegger√†?",
        },
        test: {
          en: "Let's Test!",
          zh: "Ê∏¨Ë©¶ÔºÅ",
          ja: "„ÉÜ„Çπ„ÉàÔºÅ",
          ko: "ÌÖåÏä§Ìä∏!",
          es: "¬°Probemos!",
          de: "Lass uns testen!",
          fi: "Testataan!",
          fr: "Testons !",
          ar: "ÿØÿπŸàŸÜÿß ŸÜÿÆÿ™ÿ®ÿ±!",
          it: "Testiamo!",
        },
        next: {
          en: "Next Item",
          zh: "‰∏ã‰∏ÄÂÄã",
          ja: "Ê¨°„Å∏",
          ko: "Îã§Ïùå ÏïÑÏù¥ÌÖú",
          es: "Siguiente √≠tem",
          de: "N√§chstes Element",
          fi: "Seuraava esine",
          fr: "Article suivant",
          ar: "ÿßŸÑÿπŸÜÿµÿ± ÿßŸÑÿ™ÿßŸÑŸä",
          it: "Oggetto successivo",
        },

        correct: {
          en: "Prediction Correct!",
          zh: "È†êÊ∏¨Ê≠£Á¢∫ÔºÅ",
          ja: "‰∫àÊ∏¨Ê≠£Ëß£ÔºÅ",
          ko: "ÏòàÏ∏° ÏÑ±Í≥µ!",
          es: "¬°Predicci√≥n Correcta!",
          de: "Vorhersage richtig!",
          fi: "Ennustus oikein!",
          fr: "Pr√©diction correcte !",
          ar: "ÿßŸÑÿ™ŸÜÿ®ÿ§ ÿµÿ≠Ÿäÿ≠!",
          it: "Previsione Corretta!",
        },
        wrong: {
          en: "Surprising result!",
          zh: "ÊÑèÊÉ≥‰∏çÂà∞ÁöÑÁµêÊûúÔºÅ",
          ja: "È©ö„Åç„ÅÆÁµêÊûúÔºÅ",
          ko: "ÎÜÄÎùºÏö¥ Í≤∞Í≥º!",
          es: "¬°Resultado sorprendente!",
          de: "√úberraschendes Ergebnis!",
          fi: "Yll√§tt√§v√§ tulos!",
          fr: "R√©sultat surprenant !",
          ar: "ŸÜÿ™Ÿäÿ¨ÿ© ŸÖŸÅÿßÿ¨ÿ¶ÿ©!",
          it: "Risultato sorprendente!",
        },

        // Items
        rock: {
          en: "Rock",
          zh: "Áü≥È†≠",
          ja: "Â≤©",
          ko: "Î∞îÏúÑ",
          es: "Roca",
          de: "Stein",
          fi: "Kivi",
          fr: "Rocher",
          ar: "ÿµÿÆÿ±ÿ©",
          it: "Roccia",
        },
        wood: {
          en: "Wood Block",
          zh: "Êú®Â°ä",
          ja: "Êú®„ÅÆ„Éñ„É≠„ÉÉ„ÇØ",
          ko: "ÎÇòÎ¨¥ Î∏îÎ°ù",
          es: "Bloque de madera",
          de: "Holzklotz",
          fi: "Puupalikka",
          fr: "Bloc de bois",
          ar: "ŸÉÿ™ŸÑÿ© ÿÆÿ¥ÿ®Ÿäÿ©",
          it: "Blocco di legno",
        },
        clay_ball: {
          en: "Clay Ball",
          zh: "Ê≥•ËÜ†ÁêÉ",
          ja: "Á≤òÂúü„ÅÆ„Éú„Éº„É´",
          ko: "Ï†êÌÜ† Í≥µ",
          es: "Bola de arcilla",
          de: "Tonball",
          fi: "Savipallo",
          fr: "Boule d'argile",
          ar: "ŸÉÿ±ÿ© ÿ∑ŸäŸÜŸäÿ©",
          it: "Palla di argilla",
        },
        clay_boat: {
          en: "Clay Boat",
          zh: "Ê≥•ËÜ†Ëàπ",
          ja: "Á≤òÂúü„ÅÆ„Éú„Éº„Éà",
          ko: "Ï†êÌÜ† Î∞∞",
          es: "Barco de arcilla",
          de: "Tonboot",
          fi: "Savivene",
          fr: "Bateau en argile",
          ar: "ŸÇÿßÿ±ÿ® ÿ∑ŸäŸÜŸä",
          it: "Barca di argilla",
        },
        orange_peel: {
          en: "Orange (Peeled)",
          zh: "ÂéªÁöÆÊ©ô",
          ja: "ÁöÆ„Çí„ÇÄ„ÅÑ„Åü„Ç™„É¨„É≥„Ç∏",
          ko: "ÍªçÏßà Î≤óÍ∏¥ Ïò§Î†åÏßÄ",
          es: "Naranja (Pelada)",
          de: "Orange (Gesch√§lt)",
          fi: "Appelsiini (Kuorittu)",
          fr: "Orange (Pel√©e)",
          ar: "ÿ®ÿ±ÿ™ŸÇÿßŸÑ (ŸÖŸÇÿ¥ÿ±)",
          it: "Arancia (Sbucciata)",
        },
        orange_full: {
          en: "Orange (Unpeeled)",
          zh: "ÈÄ£ÁöÆÊ©ô",
          ja: "ÁöÆ‰ªò„Åç„Ç™„É¨„É≥„Ç∏",
          ko: "ÍªçÏßà ÏûàÎäî Ïò§Î†åÏßÄ",
          es: "Naranja (Sin pelar)",
          de: "Orange (Ungesch√§lt)",
          fi: "Appelsiini (Kuorimaton)",
          fr: "Orange (Non pel√©e)",
          ar: "ÿ®ÿ±ÿ™ŸÇÿßŸÑ (ÿ∫Ÿäÿ± ŸÖŸÇÿ¥ÿ±)",
          it: "Arancia (Non sbucciata)",
        },
        coin: {
          en: "Coin",
          zh: "Á°¨Âπ£",
          ja: "„Ç≥„Ç§„É≥",
          ko: "ÎèôÏ†Ñ",
          es: "Moneda",
          de: "M√ºnze",
          fi: "Kolikko",
          fr: "Pi√®ce",
          ar: "ÿπŸÖŸÑÿ©",
          it: "Moneta",
        },
        sponge: {
          en: "Sponge",
          zh: "Êµ∑Á∂ø",
          ja: "„Çπ„Éù„É≥„Ç∏",
          ko: "Ïä§ÌéÄÏßÄ",
          es: "Esponja",
          de: "Schwamm",
          fi: "Sieni",
          fr: "√âponge",
          ar: "ÿ•ÿ≥ŸÅŸÜÿ¨ÿ©",
          it: "Spugna",
        },
      };

      const items = [
        { id: "wood", result: "float", icon: "ü™µ" },
        { id: "rock", result: "sink", icon: "ü™®" },
        { id: "clay_ball", result: "sink", icon: "‚ö´" }, // Clay ball sinks
        { id: "clay_boat", result: "float", icon: "üõ∂" }, // Clay boat floats (Shape matters!)
        { id: "orange_full", result: "float", icon: "üçä" }, // Full orange floats (air pockets in peel)
        { id: "orange_peel", result: "sink", icon: "üü†" }, // Peeled orange sinks (denser)
        { id: "coin", result: "sink", icon: "ü™ô" },
        { id: "sponge", result: "float", icon: "üßΩ" },
      ];

      function App() {
        const [lang, setLang] = useState("zh");
        const [currentItem, setCurrentItem] = useState(null);
        const [phase, setPhase] = useState("predict"); // predict, testing, result
        const [prediction, setPrediction] = useState(null);
        const [queue, setQueue] = useState([]);

        const getText = (key) => t[key][lang] || t[key]["en"];

        useEffect(() => {
          initGame();
        }, []);

        const initGame = () => {
          const q = [...items].sort(() => Math.random() - 0.5);
          setQueue(q);
          setCurrentItem(q[0]);
          setPhase("predict");
          setPrediction(null);
        };

        const handlePredict = (guess) => {
          setPrediction(guess);
          setPhase("testing");
        };

        const handleAnimationComplete = () => {
          setPhase("result");
        };

        const next = () => {
          const nextIdx = queue.indexOf(currentItem) + 1;
          if (nextIdx < queue.length) {
            setCurrentItem(queue[nextIdx]);
            setPhase("predict");
            setPrediction(null);
          } else {
            initGame(); // Reset loop
          }
        };

        // Animation variant calculation
        const dropVariants = {
          start: { y: -200, opacity: 1 },
          end: (result) => ({
            y: result === "sink" ? 150 : 0, // 0 is surface, 150 is bottom
            transition: { type: "spring", damping: 10, stiffness: 50 },
          }),
        };

        return (
          <div className="min-h-screen p-4 flex flex-col items-center select-none font-sans overflow-hidden">
            <LanguageSelector lang={lang} setLang={setLang} />

            <h1 className="text-4xl md:text-5xl font-black text-white mb-2 mt-8 drop-shadow-md">
              üö¢ {getText("title")}
            </h1>

            {currentItem && (
              <div className="w-full max-w-lg flex flex-col items-center flex-1 justify-center relative">
                {/* Item Card (Top) - Only show during prediction */}
                {phase === "predict" && (
                  <motion.div
                    initial={{ scale: 0 }}
                    animate={{ scale: 1 }}
                    className="bg-white p-6 rounded-[2rem] shadow-xl border-4 border-blue-200 mb-8 flex flex-col items-center z-20"
                  >
                    <div className="text-8xl mb-2">{currentItem.icon}</div>
                    <div className="text-xl font-bold text-slate-700">
                      {getText(currentItem.id)}
                    </div>
                  </motion.div>
                )}

                {/* Water Tank */}
                <div className="relative w-80 h-96 border-x-8 border-b-8 border-white/50 rounded-b-3xl bg-blue-400/30 overflow-hidden mb-8 shadow-2xl backdrop-blur-sm">
                  {/* Water Surface Line */}
                  <div className="absolute top-1/2 left-0 w-full h-1 bg-white/50 z-10"></div>
                  <div className="absolute top-1/2 left-0 w-full h-full bg-blue-500/50"></div>

                  {/* Bubbles */}
                  <div className="absolute top-1/2 bottom-0 left-0 w-full overflow-hidden">
                    {[...Array(5)].map((_, i) => (
                      <div
                        key={i}
                        className="absolute bg-white/30 rounded-full animate-float-up"
                        style={{
                          left: `${Math.random() * 100}%`,
                          width: `${Math.random() * 20 + 10}px`,
                          height: `${Math.random() * 20 + 10}px`,
                          animationDuration: `${Math.random() * 3 + 2}s`,
                          animationDelay: `${Math.random() * 2}s`,
                        }}
                      ></div>
                    ))}
                  </div>

                  {/* Item Animation */}
                  {phase !== "predict" && (
                    <motion.div
                      className="absolute top-1/2 left-1/2 text-8xl -translate-x-1/2 -translate-y-1/2 z-20"
                      variants={dropVariants}
                      initial="start"
                      animate="end"
                      custom={currentItem.result}
                      onAnimationComplete={handleAnimationComplete}
                    >
                      {currentItem.icon}
                    </motion.div>
                  )}
                </div>

                {/* Controls */}
                {phase === "predict" ? (
                  <div className="w-full">
                    <p className="text-white font-bold text-center mb-4 text-xl shadow-black drop-shadow-md">
                      {getText("predict")}
                    </p>
                    <div className="flex gap-4">
                      <button
                        onClick={() => handlePredict("float")}
                        className="flex-1 bg-white hover:bg-blue-50 text-blue-600 font-black text-2xl py-4 rounded-xl shadow-lg border-b-4 border-blue-200"
                      >
                        ‚¨ÜÔ∏è {getText("float")}
                      </button>
                      <button
                        onClick={() => handlePredict("sink")}
                        className="flex-1 bg-slate-800 hover:bg-slate-700 text-white font-black text-2xl py-4 rounded-xl shadow-lg border-b-4 border-slate-900"
                      >
                        ‚¨áÔ∏è {getText("sink")}
                      </button>
                    </div>
                  </div>
                ) : phase === "testing" ? (
                  <div className="text-white font-black text-3xl animate-pulse">
                    {getText("test")}
                  </div>
                ) : (
                  <div className="w-full flex flex-col items-center">
                    <div
                      className={`text-3xl font-black mb-4 px-6 py-2 rounded-xl shadow-xl ${
                        prediction === currentItem.result
                          ? "bg-green-500 text-white"
                          : "bg-yellow-400 text-black"
                      }`}
                    >
                      {prediction === currentItem.result
                        ? getText("correct")
                        : getText("wrong")}
                    </div>
                    <div className="font-bold text-white mb-6 text-xl">
                      {getText(currentItem.id)} = {getText(currentItem.result)}
                    </div>
                    <button
                      onClick={next}
                      className="bg-white text-blue-600 font-black text-xl py-3 px-12 rounded-full shadow-xl hover:scale-105 transition-transform"
                    >
                      {getText("next")} ‚û°Ô∏è
                    </button>
                  </div>
                )}
              </div>
            )}
          </div>
        );
      }
      ReactDOM.createRoot(document.getElementById("root")).render(<App />);
    </script>
  </body>
</html>
